"""Problems 21-30."""
PROBLEMS = [
    {"number": 39, "title": "Combination Sum", "difficulty": "medium", "topics": ["Arrays", "Backtracking"], "companies": ["Amazon", "Meta", "Adobe"],
     "description": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times.",
     "constraints": "1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40", "example_input": "candidates = [2,3,6,7], target = 7", "example_output": "[[2,2,3],[7]]",
     "example_explanation": "2+2+3=7 and 7=7.", "hints": "Use backtracking with a start index.\nAllow reusing the same element.", "time_complexity": "O(N^(T/M))", "space_complexity": "O(T/M)",
     "test_cases": [{"input": "candidates = [2,3,6,7]\ntarget = 7", "output": "[[2,2,3],[7]]", "is_sample": True, "explanation": "Two valid combos"},
                    {"input": "candidates = [2,3,5]\ntarget = 8", "output": "[[2,2,2,2],[2,3,3],[3,5]]", "is_sample": True, "explanation": "Three combos"},
                    {"input": "candidates = [2]\ntarget = 1", "output": "[]", "is_sample": False, "explanation": "No valid combo"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\n        pass", "solution": "class Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n        def bt(start, cur, total):\n            if total == target: res.append(cur[:]); return\n            if total > target: return\n            for i in range(start, len(candidates)):\n                cur.append(candidates[i])\n                bt(i, cur, total + candidates[i])\n                cur.pop()\n        bt(0, [], 0)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& c, int target) {\n        return {};\n    }\n};", "solution": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& c, int target) {\n        vector<vector<int>> res; vector<int> cur;\n        function<void(int,int)> bt = [&](int s, int t) {\n            if (t == 0) { res.push_back(cur); return; }\n            for (int i = s; i < c.size() && c[i] <= t; i++) {\n                cur.push_back(c[i]); bt(i, t - c[i]); cur.pop_back();\n            }\n        };\n        sort(c.begin(), c.end()); bt(0, target);\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<List<Integer>> combinationSum(int[] c, int target) {\n        return new ArrayList<>();\n    }\n}", "solution": "class Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    public List<List<Integer>> combinationSum(int[] c, int target) {\n        Arrays.sort(c); bt(c, 0, target, new ArrayList<>());\n        return res;\n    }\n    void bt(int[] c, int s, int t, List<Integer> cur) {\n        if (t == 0) { res.add(new ArrayList<>(cur)); return; }\n        for (int i = s; i < c.length && c[i] <= t; i++) {\n            cur.add(c[i]); bt(c, i, t-c[i], cur); cur.remove(cur.size()-1);\n        }\n    }\n}"},
         "javascript": {"starter": "var combinationSum = function(candidates, target) {\n};", "solution": "var combinationSum = function(candidates, target) {\n    candidates.sort((a,b)=>a-b);\n    const res = [];\n    const bt = (s, t, cur) => {\n        if (t === 0) { res.push([...cur]); return; }\n        for (let i = s; i < candidates.length && candidates[i] <= t; i++) {\n            cur.push(candidates[i]); bt(i, t-candidates[i], cur); cur.pop();\n        }\n    };\n    bt(0, target, []);\n    return res;\n};"},
         "c": {"starter": "int** combinationSum(int* c, int n, int target, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}", "solution": "int** res; int* colSz; int rSize; int cur[200]; int cLen;\nvoid bt(int* c, int n, int s, int t) {\n    if (t == 0) { res[rSize]=malloc(cLen*4); memcpy(res[rSize],cur,cLen*4); colSz[rSize++]=cLen; return; }\n    for (int i=s;i<n&&c[i]<=t;i++) { cur[cLen++]=c[i]; bt(c,n,i,t-c[i]); cLen--; }\n}\nint cmp(const void*a,const void*b){return *(int*)a-*(int*)b;}\nint** combinationSum(int* c, int n, int target, int* returnSize, int** returnColumnSizes) {\n    qsort(c,n,4,cmp); res=malloc(500*sizeof(int*)); colSz=malloc(500*4); rSize=0; cLen=0;\n    bt(c,n,0,target); *returnSize=rSize; *returnColumnSizes=colSz; return res;\n}"},
     }},
    {"number": 42, "title": "Trapping Rain Water", "difficulty": "hard", "topics": ["Arrays", "Two Pointers", "Dynamic Programming", "Stack"], "companies": ["Google", "Amazon", "Goldman Sachs"],
     "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
     "constraints": "n == height.length\n1 <= n <= 2 * 10^4\n0 <= height[i] <= 10^5", "example_input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]", "example_output": "6",
     "example_explanation": "6 units of rain water are trapped.", "hints": "Water at each position = min(maxLeft, maxRight) - height.\nUse two pointers from both ends.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]", "output": "6", "is_sample": True, "explanation": "6 units trapped"},
                    {"input": "height = [4,2,0,3,2,5]", "output": "9", "is_sample": True, "explanation": "9 units trapped"},
                    {"input": "height = [1,2,3,4,5]", "output": "0", "is_sample": False, "explanation": "Ascending, no water"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def trap(self, height: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def trap(self, height: list[int]) -> int:\n        l, r = 0, len(height) - 1\n        lmax = rmax = res = 0\n        while l < r:\n            if height[l] < height[r]:\n                if height[l] > lmax: lmax = height[l]\n                else: res += lmax - height[l]\n                l += 1\n            else:\n                if height[r] > rmax: rmax = height[r]\n                else: res += rmax - height[r]\n                r -= 1\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int trap(vector<int>& h) {\n        return 0;\n    }\n};", "solution": "class Solution {\npublic:\n    int trap(vector<int>& h) {\n        int l=0, r=h.size()-1, lm=0, rm=0, res=0;\n        while (l<r) {\n            if (h[l]<h[r]) { if(h[l]>lm) lm=h[l]; else res+=lm-h[l]; l++; }\n            else { if(h[r]>rm) rm=h[r]; else res+=rm-h[r]; r--; }\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int trap(int[] h) {\n        return 0;\n    }\n}", "solution": "class Solution {\n    public int trap(int[] h) {\n        int l=0, r=h.length-1, lm=0, rm=0, res=0;\n        while (l<r) {\n            if (h[l]<h[r]) { if(h[l]>lm) lm=h[l]; else res+=lm-h[l]; l++; }\n            else { if(h[r]>rm) rm=h[r]; else res+=rm-h[r]; r--; }\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var trap = function(height) {\n};", "solution": "var trap = function(h) {\n    let l=0, r=h.length-1, lm=0, rm=0, res=0;\n    while (l<r) {\n        if (h[l]<h[r]) { if(h[l]>lm) lm=h[l]; else res+=lm-h[l]; l++; }\n        else { if(h[r]>rm) rm=h[r]; else res+=rm-h[r]; r--; }\n    }\n    return res;\n};"},
         "c": {"starter": "int trap(int* h, int n) {\n    return 0;\n}", "solution": "int trap(int* h, int n) {\n    int l=0, r=n-1, lm=0, rm=0, res=0;\n    while (l<r) {\n        if (h[l]<h[r]) { if(h[l]>lm) lm=h[l]; else res+=lm-h[l]; l++; }\n        else { if(h[r]>rm) rm=h[r]; else res+=rm-h[r]; r--; }\n    }\n    return res;\n}"},
     }},
    {"number": 46, "title": "Permutations", "difficulty": "medium", "topics": ["Arrays", "Backtracking"], "companies": ["Microsoft", "Amazon", "Meta"],
     "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
     "constraints": "1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.", "example_input": "nums = [1,2,3]", "example_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
     "example_explanation": "All 6 permutations.", "hints": "Use backtracking with a visited set.\nSwap elements at each position.", "time_complexity": "O(n!)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [1,2,3]", "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "is_sample": True, "explanation": "6 permutations"},
                    {"input": "nums = [0,1]", "output": "[[0,1],[1,0]]", "is_sample": True, "explanation": "2 permutations"},
                    {"input": "nums = [1]", "output": "[[1]]", "is_sample": False, "explanation": "Single element"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        pass", "solution": "class Solution:\n    def permute(self, nums):\n        res = []\n        def bt(cur, remaining):\n            if not remaining: res.append(cur); return\n            for i in range(len(remaining)):\n                bt(cur + [remaining[i]], remaining[:i] + remaining[i+1:])\n        bt([], nums)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        return {};\n    }\n};", "solution": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> res;\n        function<void(int)> bt = [&](int s) {\n            if (s == nums.size()) { res.push_back(nums); return; }\n            for (int i = s; i < nums.size(); i++) {\n                swap(nums[s], nums[i]); bt(s+1); swap(nums[s], nums[i]);\n            }\n        };\n        bt(0); return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        return new ArrayList<>();\n    }\n}", "solution": "class Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        bt(nums, 0); return res;\n    }\n    void bt(int[] nums, int s) {\n        if (s == nums.length) { List<Integer> l = new ArrayList<>(); for (int n:nums) l.add(n); res.add(l); return; }\n        for (int i = s; i < nums.length; i++) {\n            int t=nums[s]; nums[s]=nums[i]; nums[i]=t;\n            bt(nums, s+1);\n            t=nums[s]; nums[s]=nums[i]; nums[i]=t;\n        }\n    }\n}"},
         "javascript": {"starter": "var permute = function(nums) {\n};", "solution": "var permute = function(nums) {\n    const res = [];\n    const bt = (cur, rem) => {\n        if (!rem.length) { res.push(cur); return; }\n        for (let i = 0; i < rem.length; i++)\n            bt([...cur, rem[i]], [...rem.slice(0,i), ...rem.slice(i+1)]);\n    };\n    bt([], nums);\n    return res;\n};"},
         "c": {"starter": "int** permute(int* nums, int n, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}", "solution": "int** res; int rSize; int* colSz;\nvoid bt(int* nums, int n, int s) {\n    if (s==n) { res[rSize]=malloc(n*4); memcpy(res[rSize],nums,n*4); colSz[rSize++]=n; return; }\n    for (int i=s;i<n;i++) {\n        int t=nums[s]; nums[s]=nums[i]; nums[i]=t;\n        bt(nums,n,s+1);\n        t=nums[s]; nums[s]=nums[i]; nums[i]=t;\n    }\n}\nint** permute(int* nums, int n, int* returnSize, int** returnColumnSizes) {\n    res=malloc(720*sizeof(int*)); colSz=malloc(720*4); rSize=0;\n    bt(nums,n,0); *returnSize=rSize; *returnColumnSizes=colSz; return res;\n}"},
     }},
    {"number": 48, "title": "Rotate Image", "difficulty": "medium", "topics": ["Arrays", "Math", "Matrix"], "companies": ["Google", "Amazon", "Apple"],
     "description": "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
     "constraints": "n == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000", "example_input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]", "example_output": "[[7,4,1],[8,5,2],[9,6,3]]",
     "example_explanation": "Rotated 90 degrees clockwise.", "hints": "Transpose the matrix first.\nThen reverse each row.", "time_complexity": "O(n^2)", "space_complexity": "O(1)",
     "test_cases": [{"input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]", "output": "[[7,4,1],[8,5,2],[9,6,3]]", "is_sample": True, "explanation": "3x3 rotation"},
                    {"input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]", "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]", "is_sample": True, "explanation": "4x4 rotation"},
                    {"input": "matrix = [[1]]", "output": "[[1]]", "is_sample": False, "explanation": "1x1 no change"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def rotate(self, matrix: list[list[int]]) -> None:\n        pass", "solution": "class Solution:\n    def rotate(self, matrix):\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for row in matrix:\n            row.reverse()"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& m) {\n    }\n};", "solution": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& m) {\n        int n = m.size();\n        for (int i=0;i<n;i++) for (int j=i+1;j<n;j++) swap(m[i][j],m[j][i]);\n        for (auto& r : m) reverse(r.begin(),r.end());\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void rotate(int[][] m) {\n    }\n}", "solution": "class Solution {\n    public void rotate(int[][] m) {\n        int n = m.length;\n        for (int i=0;i<n;i++) for (int j=i+1;j<n;j++) { int t=m[i][j]; m[i][j]=m[j][i]; m[j][i]=t; }\n        for (int[] r : m) { int l=0,ri=n-1; while(l<ri){int t=r[l];r[l]=r[ri];r[ri]=t;l++;ri--;} }\n    }\n}"},
         "javascript": {"starter": "var rotate = function(matrix) {\n};", "solution": "var rotate = function(m) {\n    const n = m.length;\n    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) [m[i][j],m[j][i]]=[m[j][i],m[i][j]];\n    for (const r of m) r.reverse();\n};"},
         "c": {"starter": "void rotate(int** m, int n, int* colSizes) {\n}", "solution": "void rotate(int** m, int n, int* cs) {\n    for (int i=0;i<n;i++) for (int j=i+1;j<n;j++) { int t=m[i][j]; m[i][j]=m[j][i]; m[j][i]=t; }\n    for (int i=0;i<n;i++) { int l=0,r=n-1; while(l<r){int t=m[i][l];m[i][l]=m[i][r];m[i][r]=t;l++;r--;} }\n}"},
     }},
    {"number": 49, "title": "Group Anagrams", "difficulty": "medium", "topics": ["Arrays", "Hash Table", "Strings", "Sorting"], "companies": ["Amazon", "Google", "Meta"],
     "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
     "constraints": "1 <= strs.length <= 10^4\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.", "example_input": 'strs = ["eat","tea","tan","ate","nat","bat"]', "example_output": '[["bat"],["nat","tan"],["ate","eat","tea"]]',
     "example_explanation": "Anagrams are grouped together.", "hints": "Sort each string to get a key.\nUse a hash map to group strings by their sorted key.", "time_complexity": "O(n*k log k)", "space_complexity": "O(n*k)",
     "test_cases": [{"input": 'strs = ["eat","tea","tan","ate","nat","bat"]', "output": '[["bat"],["nat","tan"],["ate","eat","tea"]]', "is_sample": True, "explanation": "3 groups"},
                    {"input": 'strs = [""]', "output": '[[""]]', "is_sample": True, "explanation": "Single empty string"},
                    {"input": 'strs = ["a"]', "output": '[["a"]]', "is_sample": False, "explanation": "Single character"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n        pass", "solution": "from collections import defaultdict\nclass Solution:\n    def groupAnagrams(self, strs):\n        groups = defaultdict(list)\n        for s in strs:\n            groups[tuple(sorted(s))].append(s)\n        return list(groups.values())"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        return {};\n    }\n};", "solution": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> m;\n        for (auto& s : strs) { string k = s; sort(k.begin(),k.end()); m[k].push_back(s); }\n        vector<vector<string>> res;\n        for (auto& [k,v] : m) res.push_back(v);\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        return new ArrayList<>();\n    }\n}", "solution": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> m = new HashMap<>();\n        for (String s : strs) {\n            char[] ca = s.toCharArray(); Arrays.sort(ca); String k = new String(ca);\n            m.computeIfAbsent(k, x -> new ArrayList<>()).add(s);\n        }\n        return new ArrayList<>(m.values());\n    }\n}"},
         "javascript": {"starter": "var groupAnagrams = function(strs) {\n};", "solution": "var groupAnagrams = function(strs) {\n    const m = new Map();\n    for (const s of strs) {\n        const k = s.split('').sort().join('');\n        if (!m.has(k)) m.set(k, []);\n        m.get(k).push(s);\n    }\n    return [...m.values()];\n};"},
         "c": {"starter": "char*** groupAnagrams(char** strs, int n, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}", "solution": "// C implementation omitted for brevity - use sorting-based grouping\nchar*** groupAnagrams(char** strs, int n, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}"},
     }},
    {"number": 53, "title": "Maximum Subarray", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Microsoft", "Google"],
     "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
     "constraints": "1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4", "example_input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "example_output": "6",
     "example_explanation": "The subarray [4,-1,2,1] has the largest sum 6.", "hints": "Use Kadane's algorithm.\nKeep track of current sum and max sum.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "6", "is_sample": True, "explanation": "Subarray [4,-1,2,1]"},
                    {"input": "nums = [1]", "output": "1", "is_sample": True, "explanation": "Single element"},
                    {"input": "nums = [5,4,-1,7,8]", "output": "23", "is_sample": False, "explanation": "Entire array"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxSubArray(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def maxSubArray(self, nums):\n        cur = best = nums[0]\n        for n in nums[1:]:\n            cur = max(n, cur + n)\n            best = max(best, cur)\n        return best"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        return 0;\n    }\n};", "solution": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int cur = nums[0], best = nums[0];\n        for (int i=1;i<nums.size();i++) {\n            cur = max(nums[i], cur+nums[i]);\n            best = max(best, cur);\n        }\n        return best;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int maxSubArray(int[] nums) {\n        return 0;\n    }\n}", "solution": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int cur = nums[0], best = nums[0];\n        for (int i=1;i<nums.length;i++) {\n            cur = Math.max(nums[i], cur+nums[i]);\n            best = Math.max(best, cur);\n        }\n        return best;\n    }\n}"},
         "javascript": {"starter": "var maxSubArray = function(nums) {\n};", "solution": "var maxSubArray = function(nums) {\n    let cur = nums[0], best = nums[0];\n    for (let i=1;i<nums.length;i++) {\n        cur = Math.max(nums[i], cur+nums[i]);\n        best = Math.max(best, cur);\n    }\n    return best;\n};"},
         "c": {"starter": "int maxSubArray(int* nums, int n) {\n    return 0;\n}", "solution": "int maxSubArray(int* nums, int n) {\n    int cur = nums[0], best = nums[0];\n    for (int i=1;i<n;i++) {\n        cur = nums[i] > cur+nums[i] ? nums[i] : cur+nums[i];\n        if (cur > best) best = cur;\n    }\n    return best;\n}"},
     }},
    {"number": 55, "title": "Jump Game", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming", "Greedy"], "companies": ["Amazon", "Google", "Microsoft"],
     "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
     "constraints": "1 <= nums.length <= 10^4\n0 <= nums[i] <= 10^5", "example_input": "nums = [2,3,1,1,4]", "example_output": "true",
     "example_explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index.", "hints": "Track the farthest reachable position.\nIf current index exceeds farthest, return false.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [2,3,1,1,4]", "output": "true", "is_sample": True, "explanation": "Can reach end"},
                    {"input": "nums = [3,2,1,0,4]", "output": "false", "is_sample": True, "explanation": "Stuck at index 3"},
                    {"input": "nums = [0]", "output": "true", "is_sample": False, "explanation": "Already at end"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def canJump(self, nums: list[int]) -> bool:\n        pass", "solution": "class Solution:\n    def canJump(self, nums):\n        far = 0\n        for i in range(len(nums)):\n            if i > far: return False\n            far = max(far, i + nums[i])\n        return True"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        return false;\n    }\n};", "solution": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int far = 0;\n        for (int i=0;i<nums.size();i++) {\n            if (i > far) return false;\n            far = max(far, i+nums[i]);\n        }\n        return true;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean canJump(int[] nums) {\n        return false;\n    }\n}", "solution": "class Solution {\n    public boolean canJump(int[] nums) {\n        int far = 0;\n        for (int i=0;i<nums.length;i++) {\n            if (i > far) return false;\n            far = Math.max(far, i+nums[i]);\n        }\n        return true;\n    }\n}"},
         "javascript": {"starter": "var canJump = function(nums) {\n};", "solution": "var canJump = function(nums) {\n    let far = 0;\n    for (let i=0;i<nums.length;i++) {\n        if (i > far) return false;\n        far = Math.max(far, i+nums[i]);\n    }\n    return true;\n};"},
         "c": {"starter": "#include <stdbool.h>\nbool canJump(int* nums, int n) {\n    return false;\n}", "solution": "bool canJump(int* nums, int n) {\n    int far = 0;\n    for (int i=0;i<n;i++) {\n        if (i > far) return false;\n        if (i+nums[i] > far) far = i+nums[i];\n    }\n    return true;\n}"},
     }},
    {"number": 56, "title": "Merge Intervals", "difficulty": "medium", "topics": ["Arrays", "Sorting"], "companies": ["Google", "Meta", "Amazon"],
     "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
     "constraints": "1 <= intervals.length <= 10^4\nintervals[i].length == 2\n0 <= start_i <= end_i <= 10^4", "example_input": "intervals = [[1,3],[2,6],[8,10],[15,18]]", "example_output": "[[1,6],[8,10],[15,18]]",
     "example_explanation": "Intervals [1,3] and [2,6] overlap, merge to [1,6].", "hints": "Sort intervals by start time.\nMerge if current start <= previous end.", "time_complexity": "O(n log n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "intervals = [[1,3],[2,6],[8,10],[15,18]]", "output": "[[1,6],[8,10],[15,18]]", "is_sample": True, "explanation": "Merge [1,3] and [2,6]"},
                    {"input": "intervals = [[1,4],[4,5]]", "output": "[[1,5]]", "is_sample": True, "explanation": "Touching intervals merge"},
                    {"input": "intervals = [[1,4],[0,4]]", "output": "[[0,4]]", "is_sample": False, "explanation": "Overlapping, needs sort"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        pass", "solution": "class Solution:\n    def merge(self, intervals):\n        intervals.sort()\n        res = [intervals[0]]\n        for s, e in intervals[1:]:\n            if s <= res[-1][1]:\n                res[-1][1] = max(res[-1][1], e)\n            else:\n                res.append([s, e])\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        return {};\n    }\n};", "solution": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> res = {intervals[0]};\n        for (int i=1;i<intervals.size();i++) {\n            if (intervals[i][0] <= res.back()[1]) res.back()[1] = max(res.back()[1], intervals[i][1]);\n            else res.push_back(intervals[i]);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        return new int[][]{};\n    }\n}", "solution": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a,b)->a[0]-b[0]);\n        List<int[]> res = new ArrayList<>();\n        res.add(intervals[0]);\n        for (int i=1;i<intervals.length;i++) {\n            int[] last = res.get(res.size()-1);\n            if (intervals[i][0] <= last[1]) last[1] = Math.max(last[1], intervals[i][1]);\n            else res.add(intervals[i]);\n        }\n        return res.toArray(new int[0][]);\n    }\n}"},
         "javascript": {"starter": "var merge = function(intervals) {\n};", "solution": "var merge = function(intervals) {\n    intervals.sort((a,b)=>a[0]-b[0]);\n    const res = [intervals[0]];\n    for (let i=1;i<intervals.length;i++) {\n        if (intervals[i][0] <= res[res.length-1][1])\n            res[res.length-1][1] = Math.max(res[res.length-1][1], intervals[i][1]);\n        else res.push(intervals[i]);\n    }\n    return res;\n};"},
         "c": {"starter": "int** merge(int** intervals, int n, int* colSizes, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}", "solution": "int cmp(const void*a,const void*b){return (*(int**)a)[0]-(*(int**)b)[0];}\nint** merge(int** iv, int n, int* cs, int* rs, int** rcs) {\n    qsort(iv,n,sizeof(int*),cmp);\n    int** res=malloc(n*sizeof(int*)); *rcs=malloc(n*4);\n    res[0]=malloc(8); res[0][0]=iv[0][0]; res[0][1]=iv[0][1]; (*rcs)[0]=2; *rs=1;\n    for(int i=1;i<n;i++){\n        if(iv[i][0]<=res[*rs-1][1]) { if(iv[i][1]>res[*rs-1][1]) res[*rs-1][1]=iv[i][1]; }\n        else { res[*rs]=malloc(8); res[*rs][0]=iv[i][0]; res[*rs][1]=iv[i][1]; (*rcs)[*rs]=2; (*rs)++; }\n    }\n    return res;\n}"},
     }},
    {"number": 62, "title": "Unique Paths", "difficulty": "medium", "topics": ["Math", "Dynamic Programming"], "companies": ["Google", "Amazon", "Bloomberg"],
     "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner. The robot tries to move to the bottom-right corner. The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
     "constraints": "1 <= m, n <= 100", "example_input": "m = 3, n = 7", "example_output": "28",
     "example_explanation": "28 unique paths from top-left to bottom-right.", "hints": "Use DP: dp[i][j] = dp[i-1][j] + dp[i][j-1].\nFirst row and first column are all 1s.", "time_complexity": "O(m*n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "m = 3\nn = 7", "output": "28", "is_sample": True, "explanation": "28 paths"},
                    {"input": "m = 3\nn = 2", "output": "3", "is_sample": True, "explanation": "3 paths"},
                    {"input": "m = 1\nn = 1", "output": "1", "is_sample": False, "explanation": "Already there"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        pass", "solution": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [1] * n\n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j-1]\n        return dp[-1]"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        return 0;\n    }\n};", "solution": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n, 1);\n        for (int i=1;i<m;i++) for (int j=1;j<n;j++) dp[j]+=dp[j-1];\n        return dp[n-1];\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int uniquePaths(int m, int n) {\n        return 0;\n    }\n}", "solution": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[n]; Arrays.fill(dp, 1);\n        for (int i=1;i<m;i++) for (int j=1;j<n;j++) dp[j]+=dp[j-1];\n        return dp[n-1];\n    }\n}"},
         "javascript": {"starter": "var uniquePaths = function(m, n) {\n};", "solution": "var uniquePaths = function(m, n) {\n    const dp = new Array(n).fill(1);\n    for (let i=1;i<m;i++) for (let j=1;j<n;j++) dp[j]+=dp[j-1];\n    return dp[n-1];\n};"},
         "c": {"starter": "int uniquePaths(int m, int n) {\n    return 0;\n}", "solution": "int uniquePaths(int m, int n) {\n    int dp[100]; for(int i=0;i<n;i++) dp[i]=1;\n    for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[j]+=dp[j-1];\n    return dp[n-1];\n}"},
     }},
]
