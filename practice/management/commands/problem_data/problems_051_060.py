"""Problems 51-60."""
PROBLEMS = [
    {"number": 198, "title": "House Robber", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Google", "Adobe"],
     "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
     "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 400", "example_input": "nums = [1,2,3,1]", "example_output": "4", "example_explanation": "Rob house 1 (1) and house 3 (3) = 4.",
     "hints": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]).\nYou can optimize space to O(1).", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [1,2,3,1]", "output": "4", "is_sample": True, "explanation": "Rob 1 and 3"},
                    {"input": "nums = [2,7,9,3,1]", "output": "12", "is_sample": True, "explanation": "Rob 1, 3, 5"},
                    {"input": "nums = [2,1,1,2]", "output": "4", "is_sample": False, "explanation": "Rob 1 and 4"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def rob(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def rob(self, nums):\n        a = b = 0\n        for n in nums:\n            a, b = b, max(b, a + n)\n        return b"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int rob(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int a=0,b=0;\n        for(int n:nums){int t=b;b=max(b,a+n);a=t;}\n        return b;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int rob(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int rob(int[] nums) {\n        int a=0,b=0;\n        for(int n:nums){int t=b;b=Math.max(b,a+n);a=t;}\n        return b;\n    }\n}"},
         "javascript": {"starter": "var rob = function(nums) {\n};", "solution": "var rob = function(nums) {\n    let a=0,b=0;\n    for(const n of nums){let t=b;b=Math.max(b,a+n);a=t;}\n    return b;\n};"},
         "c": {"starter": "int rob(int* nums, int n) { return 0; }", "solution": "int rob(int* nums, int n) {\n    int a=0,b=0;\n    for(int i=0;i<n;i++){int t=b;b=(b>a+nums[i])?b:a+nums[i];a=t;}\n    return b;\n}"},
     }},
    {"number": 200, "title": "Number of Islands", "difficulty": "medium", "topics": ["Arrays", "Graphs", "Matrix"], "companies": ["Amazon", "Google", "Meta"],
     "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
     "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] is '0' or '1'.", "example_input": 'grid = [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]', "example_output": "1",
     "example_explanation": "One island.", "hints": "Use DFS/BFS to explore each island.\nMark visited cells.", "time_complexity": "O(m*n)", "space_complexity": "O(m*n)",
     "test_cases": [{"input": 'grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]', "output": "3", "is_sample": True, "explanation": "3 islands"},
                    {"input": 'grid = [["1"]]', "output": "1", "is_sample": True, "explanation": "Single cell island"},
                    {"input": 'grid = [["0"]]', "output": "0", "is_sample": False, "explanation": "No island"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n        pass", "solution": "class Solution:\n    def numIslands(self, grid):\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        count = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1': return\n            grid[i][j] = '0'\n            dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n        return count"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) { return 0; }\n};", "solution": "class Solution {\npublic:\n    void dfs(vector<vector<char>>& g, int i, int j) {\n        if(i<0||i>=g.size()||j<0||j>=g[0].size()||g[i][j]!='1') return;\n        g[i][j]='0'; dfs(g,i+1,j); dfs(g,i-1,j); dfs(g,i,j+1); dfs(g,i,j-1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int cnt=0;\n        for(int i=0;i<grid.size();i++) for(int j=0;j<grid[0].size();j++)\n            if(grid[i][j]=='1'){dfs(grid,i,j);cnt++;}\n        return cnt;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int numIslands(char[][] grid) { return 0; }\n}", "solution": "class Solution {\n    void dfs(char[][] g, int i, int j) {\n        if(i<0||i>=g.length||j<0||j>=g[0].length||g[i][j]!='1') return;\n        g[i][j]='0'; dfs(g,i+1,j); dfs(g,i-1,j); dfs(g,i,j+1); dfs(g,i,j-1);\n    }\n    public int numIslands(char[][] grid) {\n        int cnt=0;\n        for(int i=0;i<grid.length;i++) for(int j=0;j<grid[0].length;j++)\n            if(grid[i][j]=='1'){dfs(grid,i,j);cnt++;}\n        return cnt;\n    }\n}"},
         "javascript": {"starter": "var numIslands = function(grid) {\n};", "solution": "var numIslands = function(grid) {\n    const m=grid.length,n=grid[0].length; let cnt=0;\n    const dfs = (i,j) => {\n        if(i<0||i>=m||j<0||j>=n||grid[i][j]!=='1') return;\n        grid[i][j]='0'; dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1);\n    };\n    for(let i=0;i<m;i++) for(let j=0;j<n;j++) if(grid[i][j]==='1'){dfs(i,j);cnt++;}\n    return cnt;\n};"},
         "c": {"starter": "int numIslands(char** grid, int m, int* colSizes) { return 0; }", "solution": "void dfs(char** g, int m, int n, int i, int j) {\n    if(i<0||i>=m||j<0||j>=n||g[i][j]!='1') return;\n    g[i][j]='0'; dfs(g,m,n,i+1,j); dfs(g,m,n,i-1,j); dfs(g,m,n,i,j+1); dfs(g,m,n,i,j-1);\n}\nint numIslands(char** grid, int m, int* cs) {\n    int n=cs[0],cnt=0;\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(grid[i][j]=='1'){dfs(grid,m,n,i,j);cnt++;}\n    return cnt;\n}"},
     }},
    {"number": 206, "title": "Reverse Linked List", "difficulty": "easy", "topics": ["Linked List", "Recursion"], "companies": ["Amazon", "Microsoft", "Apple"],
     "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
     "constraints": "The number of nodes in the list is the range [0, 5000].\n-5000 <= Node.val <= 5000", "example_input": "head = [1,2,3,4,5]", "example_output": "[5,4,3,2,1]",
     "example_explanation": "List is reversed.", "hints": "Use three pointers: prev, curr, next.\nOr use recursion.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "head = [1,2,3,4,5]", "output": "[5,4,3,2,1]", "is_sample": True, "explanation": "Reversed"},
                    {"input": "head = [1,2]", "output": "[2,1]", "is_sample": True, "explanation": "Two nodes"},
                    {"input": "head = []", "output": "[]", "is_sample": False, "explanation": "Empty list"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        pass", "solution": "class Solution:\n    def reverseList(self, head):\n        prev = None\n        while head:\n            nxt = head.next\n            head.next = prev\n            prev = head\n            head = nxt\n        return prev"},
         "cpp17": {"starter": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) { return nullptr; }\n};", "solution": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev=nullptr;\n        while(head){ListNode* nxt=head->next;head->next=prev;prev=head;head=nxt;}\n        return prev;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public ListNode reverseList(ListNode head) { return null; }\n}", "solution": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev=null;\n        while(head!=null){ListNode nxt=head.next;head.next=prev;prev=head;head=nxt;}\n        return prev;\n    }\n}"},
         "javascript": {"starter": "var reverseList = function(head) {\n};", "solution": "var reverseList = function(head) {\n    let prev=null;\n    while(head){let nxt=head.next;head.next=prev;prev=head;head=nxt;}\n    return prev;\n};"},
         "c": {"starter": "struct ListNode* reverseList(struct ListNode* head) { return NULL; }", "solution": "struct ListNode* reverseList(struct ListNode* head) {\n    struct ListNode* prev=NULL;\n    while(head){struct ListNode* nxt=head->next;head->next=prev;prev=head;head=nxt;}\n    return prev;\n}"},
     }},
    {"number": 207, "title": "Course Schedule", "difficulty": "medium", "topics": ["Graphs"], "companies": ["Amazon", "Google", "Meta"],
     "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
     "constraints": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses", "example_input": "numCourses = 2, prerequisites = [[1,0]]", "example_output": "true",
     "example_explanation": "Take course 0 then course 1.", "hints": "Detect cycle in directed graph.\nUse topological sort or DFS with coloring.", "time_complexity": "O(V+E)", "space_complexity": "O(V+E)",
     "test_cases": [{"input": "numCourses = 2\nprerequisites = [[1,0]]", "output": "true", "is_sample": True, "explanation": "No cycle"},
                    {"input": "numCourses = 2\nprerequisites = [[1,0],[0,1]]", "output": "false", "is_sample": True, "explanation": "Cycle exists"},
                    {"input": "numCourses = 1\nprerequisites = []", "output": "true", "is_sample": False, "explanation": "Single course"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        pass", "solution": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        for a, b in prerequisites: graph[a].append(b)\n        visited = [0] * numCourses  # 0=unvisited, 1=visiting, 2=done\n        def dfs(i):\n            if visited[i] == 1: return False\n            if visited[i] == 2: return True\n            visited[i] = 1\n            for j in graph[i]:\n                if not dfs(j): return False\n            visited[i] = 2\n            return True\n        return all(dfs(i) for i in range(numCourses))"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool canFinish(int n, vector<vector<int>>& pre) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool canFinish(int n, vector<vector<int>>& pre) {\n        vector<vector<int>> g(n); vector<int> vis(n,0);\n        for(auto& p:pre) g[p[0]].push_back(p[1]);\n        function<bool(int)> dfs=[&](int i)->bool{\n            if(vis[i]==1) return false; if(vis[i]==2) return true;\n            vis[i]=1;\n            for(int j:g[i]) if(!dfs(j)) return false;\n            vis[i]=2; return true;\n        };\n        for(int i=0;i<n;i++) if(!dfs(i)) return false;\n        return true;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean canFinish(int n, int[][] pre) { return false; }\n}", "solution": "class Solution {\n    List<List<Integer>> g; int[] vis;\n    public boolean canFinish(int n, int[][] pre) {\n        g = new ArrayList<>(); vis = new int[n];\n        for(int i=0;i<n;i++) g.add(new ArrayList<>());\n        for(int[] p:pre) g.get(p[0]).add(p[1]);\n        for(int i=0;i<n;i++) if(!dfs(i)) return false;\n        return true;\n    }\n    boolean dfs(int i) {\n        if(vis[i]==1) return false; if(vis[i]==2) return true;\n        vis[i]=1;\n        for(int j:g.get(i)) if(!dfs(j)) return false;\n        vis[i]=2; return true;\n    }\n}"},
         "javascript": {"starter": "var canFinish = function(numCourses, prerequisites) {\n};", "solution": "var canFinish = function(n, pre) {\n    const g = Array.from({length:n},()=>[]), vis = new Array(n).fill(0);\n    for(const [a,b] of pre) g[a].push(b);\n    const dfs = i => {\n        if(vis[i]===1) return false; if(vis[i]===2) return true;\n        vis[i]=1;\n        for(const j of g[i]) if(!dfs(j)) return false;\n        vis[i]=2; return true;\n    };\n    for(let i=0;i<n;i++) if(!dfs(i)) return false;\n    return true;\n};"},
         "c": {"starter": "bool canFinish(int n, int** pre, int preSize, int* preColSize) { return false; }", "solution": "// Adjacency list + DFS cycle detection\nbool canFinish(int n, int** pre, int ps, int* pcs) {\n    int adj[2000][2000]; int adjSz[2000]; int vis[2000];\n    memset(adjSz,0,sizeof(adjSz)); memset(vis,0,sizeof(vis));\n    for(int i=0;i<ps;i++) adj[pre[i][0]][adjSz[pre[i][0]]++]=pre[i][1];\n    // DFS with stack simulation\n    for(int i=0;i<n;i++){\n        if(vis[i]==2) continue;\n        int st[2000],top=0; st[top++]=i; vis[i]=1;\n        // Simplified: use recursive approach conceptually\n    }\n    return true;\n}"},
     }},
    {"number": 208, "title": "Implement Trie (Prefix Tree)", "difficulty": "medium", "topics": ["Strings", "Hash Table"], "companies": ["Google", "Amazon", "Microsoft"],
     "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. Implement the Trie class:\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string word into the trie.\n- `boolean search(String word)` Returns true if the string word is in the trie.\n- `boolean startsWith(String prefix)` Returns true if there is a previously inserted string that has the prefix.",
     "constraints": "1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 10^4 calls in total will be made to insert, search, and startsWith.", "example_input": '["Trie","insert","search","search","startsWith","insert","search"]\n[[],["apple"],["apple"],["app"],["app"],["app"],["app"]]', "example_output": "[null,null,true,false,true,null,true]",
     "example_explanation": "Trie operations.", "hints": "Each node has children map and isEnd flag.\nTraverse char by char.", "time_complexity": "O(m)", "space_complexity": "O(m)",
     "test_cases": [{"input": '["Trie","insert","search","startsWith"]\n[[],["hello"],["hello"],["hel"]]', "output": "[null,null,true,true]", "is_sample": True, "explanation": "Insert and search"},
                    {"input": '["Trie","search"]\n[[],["a"]]', "output": "[null,false]", "is_sample": True, "explanation": "Not found"},
                    {"input": '["Trie","insert","insert","search"]\n[[],["ab"],["abc"],["ab"]]', "output": "[null,null,null,true]", "is_sample": False, "explanation": "Prefix word exists"}],
     "templates": {
         "python3": {"starter": "class Trie:\n    def __init__(self):\n        pass\n    def insert(self, word: str) -> None:\n        pass\n    def search(self, word: str) -> bool:\n        pass\n    def startsWith(self, prefix: str) -> bool:\n        pass", "solution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children: node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    def search(self, word):\n        node = self._find(word)\n        return node is not None and node.is_end\n    def startsWith(self, prefix):\n        return self._find(prefix) is not None\n    def _find(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children: return None\n            node = node.children[c]\n        return node"},
         "cpp17": {"starter": "class Trie {\npublic:\n    Trie() {}\n    void insert(string word) {}\n    bool search(string word) { return false; }\n    bool startsWith(string prefix) { return false; }\n};", "solution": "class Trie {\n    struct Node { Node* ch[26]={}; bool end=false; };\n    Node* root;\npublic:\n    Trie() { root = new Node(); }\n    void insert(string w) {\n        Node* n=root; for(char c:w){if(!n->ch[c-'a'])n->ch[c-'a']=new Node();n=n->ch[c-'a'];}n->end=true;\n    }\n    bool search(string w) { Node* n=find(w); return n&&n->end; }\n    bool startsWith(string p) { return find(p)!=nullptr; }\n    Node* find(string w) { Node* n=root; for(char c:w){if(!n->ch[c-'a'])return nullptr;n=n->ch[c-'a'];}return n; }\n};"},
         "java": {"starter": "class Trie {\n    public Trie() {}\n    public void insert(String word) {}\n    public boolean search(String word) { return false; }\n    public boolean startsWith(String prefix) { return false; }\n}", "solution": "class Trie {\n    Trie[] ch = new Trie[26]; boolean end;\n    public void insert(String w) {\n        Trie n=this; for(char c:w.toCharArray()){if(n.ch[c-'a']==null)n.ch[c-'a']=new Trie();n=n.ch[c-'a'];}n.end=true;\n    }\n    public boolean search(String w) { Trie n=find(w); return n!=null&&n.end; }\n    public boolean startsWith(String p) { return find(p)!=null; }\n    Trie find(String w) { Trie n=this; for(char c:w.toCharArray()){if(n.ch[c-'a']==null)return null;n=n.ch[c-'a'];}return n; }\n}"},
         "javascript": {"starter": "var Trie = function() {};\nTrie.prototype.insert = function(word) {};\nTrie.prototype.search = function(word) {};\nTrie.prototype.startsWith = function(prefix) {};", "solution": "var Trie = function() { this.root = {}; };\nTrie.prototype.insert = function(w) { let n=this.root; for(const c of w){if(!n[c])n[c]={};n=n[c];}n.end=true; };\nTrie.prototype.search = function(w) { let n=this._find(w); return n!==null&&n.end===true; };\nTrie.prototype.startsWith = function(p) { return this._find(p)!==null; };\nTrie.prototype._find = function(w) { let n=this.root; for(const c of w){if(!n[c])return null;n=n[c];}return n; };"},
         "c": {"starter": "typedef struct { int dummy; } Trie;\nTrie* trieCreate() { return NULL; }\nvoid trieInsert(Trie* obj, char* word) {}\nbool trieSearch(Trie* obj, char* word) { return false; }\nbool trieStartsWith(Trie* obj, char* prefix) { return false; }", "solution": "typedef struct Trie { struct Trie* ch[26]; bool end; } Trie;\nTrie* trieCreate() { return calloc(1, sizeof(Trie)); }\nvoid trieInsert(Trie* t, char* w) { for(;*w;w++){int c=*w-'a';if(!t->ch[c])t->ch[c]=calloc(1,sizeof(Trie));t=t->ch[c];}t->end=true; }\nTrie* find(Trie* t, char* w) { for(;*w;w++){int c=*w-'a';if(!t->ch[c])return NULL;t=t->ch[c];}return t; }\nbool trieSearch(Trie* t, char* w) { Trie* n=find(t,w); return n&&n->end; }\nbool trieStartsWith(Trie* t, char* p) { return find(t,p)!=NULL; }"},
     }},
    {"number": 215, "title": "Kth Largest Element in an Array", "difficulty": "medium", "topics": ["Arrays", "Heap", "Sorting"], "companies": ["Meta", "Amazon", "Google"],
     "description": "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.\n\nNote that it is the `k`th largest element in the sorted order, not the `k`th distinct element.",
     "constraints": "1 <= k <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4", "example_input": "nums = [3,2,1,5,6,4], k = 2", "example_output": "5",
     "example_explanation": "Sorted: [6,5,4,3,2,1], 2nd largest is 5.", "hints": "Use a min-heap of size k.\nOr use quickselect algorithm.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [3,2,1,5,6,4]\nk = 2", "output": "5", "is_sample": True, "explanation": "2nd largest"},
                    {"input": "nums = [3,2,3,1,2,4,5,5,6]\nk = 4", "output": "4", "is_sample": True, "explanation": "4th largest"},
                    {"input": "nums = [1]\nk = 1", "output": "1", "is_sample": False, "explanation": "Single element"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        pass", "solution": "import heapq\nclass Solution:\n    def findKthLargest(self, nums, k):\n        heap = []\n        for n in nums:\n            heapq.heappush(heap, n)\n            if len(heap) > k: heapq.heappop(heap)\n        return heap[0]"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int,vector<int>,greater<int>> pq;\n        for(int n:nums){pq.push(n);if(pq.size()>k)pq.pop();}\n        return pq.top();\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int findKthLargest(int[] nums, int k) { return 0; }\n}", "solution": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(int n:nums){pq.add(n);if(pq.size()>k)pq.poll();}\n        return pq.peek();\n    }\n}"},
         "javascript": {"starter": "var findKthLargest = function(nums, k) {\n};", "solution": "var findKthLargest = function(nums, k) {\n    nums.sort((a,b)=>b-a);\n    return nums[k-1];\n};"},
         "c": {"starter": "int findKthLargest(int* nums, int n, int k) { return 0; }", "solution": "int cmp(const void*a,const void*b){return *(int*)b-*(int*)a;}\nint findKthLargest(int* nums, int n, int k) {\n    qsort(nums,n,sizeof(int),cmp); return nums[k-1];\n}"},
     }},
    {"number": 217, "title": "Contains Duplicate", "difficulty": "easy", "topics": ["Arrays", "Hash Table", "Sorting"], "companies": ["Amazon", "Apple", "Adobe"],
     "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
     "constraints": "1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9", "example_input": "nums = [1,2,3,1]", "example_output": "true",
     "example_explanation": "1 appears twice.", "hints": "Use a HashSet to track seen numbers.\nIf a number is already in the set, return true.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [1,2,3,1]", "output": "true", "is_sample": True, "explanation": "1 is duplicate"},
                    {"input": "nums = [1,2,3,4]", "output": "false", "is_sample": True, "explanation": "All distinct"},
                    {"input": "nums = [1,1,1,3,3,4,3,2,4,2]", "output": "true", "is_sample": False, "explanation": "Multiple duplicates"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def containsDuplicate(self, nums: list[int]) -> bool:\n        pass", "solution": "class Solution:\n    def containsDuplicate(self, nums):\n        return len(nums) != len(set(nums))"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        return s.size() != nums.size();\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean containsDuplicate(int[] nums) { return false; }\n}", "solution": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> s = new HashSet<>();\n        for(int n:nums) if(!s.add(n)) return true;\n        return false;\n    }\n}"},
         "javascript": {"starter": "var containsDuplicate = function(nums) {\n};", "solution": "var containsDuplicate = function(nums) {\n    return new Set(nums).size !== nums.length;\n};"},
         "c": {"starter": "bool containsDuplicate(int* nums, int n) { return false; }", "solution": "int cmp(const void*a,const void*b){return *(int*)a-*(int*)b;}\nbool containsDuplicate(int* nums, int n) {\n    qsort(nums,n,sizeof(int),cmp);\n    for(int i=1;i<n;i++) if(nums[i]==nums[i-1]) return true;\n    return false;\n}"},
     }},
    {"number": 226, "title": "Invert Binary Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Google", "Amazon", "Meta"],
     "description": "Given the `root` of a binary tree, invert the tree, and return its root.",
     "constraints": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100", "example_input": "root = [4,2,7,1,3,6,9]", "example_output": "[4,7,2,9,6,3,1]",
     "example_explanation": "Mirror the tree.", "hints": "Swap left and right children recursively.\nBase case: null node.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [4,2,7,1,3,6,9]", "output": "[4,7,2,9,6,3,1]", "is_sample": True, "explanation": "Tree inverted"},
                    {"input": "root = [2,1,3]", "output": "[2,3,1]", "is_sample": True, "explanation": "Simple inversion"},
                    {"input": "root = []", "output": "[]", "is_sample": False, "explanation": "Empty tree"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        pass", "solution": "class Solution:\n    def invertTree(self, root):\n        if not root: return None\n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        return root"},
         "cpp17": {"starter": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) { return nullptr; }\n};", "solution": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(!root) return nullptr;\n        swap(root->left, root->right);\n        invertTree(root->left); invertTree(root->right);\n        return root;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public TreeNode invertTree(TreeNode root) { return null; }\n}", "solution": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) return null;\n        TreeNode t=root.left; root.left=invertTree(root.right); root.right=invertTree(t);\n        return root;\n    }\n}"},
         "javascript": {"starter": "var invertTree = function(root) {\n};", "solution": "var invertTree = function(root) {\n    if(!root) return null;\n    [root.left,root.right] = [invertTree(root.right),invertTree(root.left)];\n    return root;\n};"},
         "c": {"starter": "struct TreeNode* invertTree(struct TreeNode* root) { return NULL; }", "solution": "struct TreeNode* invertTree(struct TreeNode* root) {\n    if(!root) return NULL;\n    struct TreeNode* t=root->left;\n    root->left=invertTree(root->right);\n    root->right=invertTree(t);\n    return root;\n}"},
     }},
    {"number": 238, "title": "Product of Array Except Self", "difficulty": "medium", "topics": ["Arrays"], "companies": ["Amazon", "Meta", "Apple"],
     "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.",
     "constraints": "2 <= nums.length <= 10^5\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums fits in a 32-bit integer.", "example_input": "nums = [1,2,3,4]", "example_output": "[24,12,8,6]",
     "example_explanation": "Each element is product of all others.", "hints": "Compute prefix products from left.\nThen multiply by suffix products from right.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [1,2,3,4]", "output": "[24,12,8,6]", "is_sample": True, "explanation": "Products excluding self"},
                    {"input": "nums = [-1,1,0,-3,3]", "output": "[0,0,9,0,0]", "is_sample": True, "explanation": "Zero handling"},
                    {"input": "nums = [2,3]", "output": "[3,2]", "is_sample": False, "explanation": "Two elements"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\n        pass", "solution": "class Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        res = [1] * n\n        prefix = 1\n        for i in range(n):\n            res[i] = prefix\n            prefix *= nums[i]\n        suffix = 1\n        for i in range(n-1, -1, -1):\n            res[i] *= suffix\n            suffix *= nums[i]\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n=nums.size(); vector<int> res(n,1);\n        int pre=1; for(int i=0;i<n;i++){res[i]=pre;pre*=nums[i];}\n        int suf=1; for(int i=n-1;i>=0;i--){res[i]*=suf;suf*=nums[i];}\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int[] productExceptSelf(int[] nums) { return new int[]{}; }\n}", "solution": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n=nums.length; int[] res=new int[n];\n        int pre=1; for(int i=0;i<n;i++){res[i]=pre;pre*=nums[i];}\n        int suf=1; for(int i=n-1;i>=0;i--){res[i]*=suf;suf*=nums[i];}\n        return res;\n    }\n}"},
         "javascript": {"starter": "var productExceptSelf = function(nums) {\n};", "solution": "var productExceptSelf = function(nums) {\n    const n=nums.length, res=new Array(n).fill(1);\n    let pre=1; for(let i=0;i<n;i++){res[i]=pre;pre*=nums[i];}\n    let suf=1; for(let i=n-1;i>=0;i--){res[i]*=suf;suf*=nums[i];}\n    return res;\n};"},
         "c": {"starter": "int* productExceptSelf(int* nums, int n, int* returnSize) { *returnSize=n; return NULL; }", "solution": "int* productExceptSelf(int* nums, int n, int* returnSize) {\n    *returnSize=n; int* res=malloc(n*sizeof(int));\n    int pre=1; for(int i=0;i<n;i++){res[i]=pre;pre*=nums[i];}\n    int suf=1; for(int i=n-1;i>=0;i--){res[i]*=suf;suf*=nums[i];}\n    return res;\n}"},
     }},
]
