"""Problems 91-100+."""
PROBLEMS = [
    {"number": 114, "title": "Flatten Binary Tree to Linked List", "difficulty": "medium", "topics": ["Trees", "Linked List", "Stack"], "companies": ["Amazon", "Meta", "Microsoft"],
     "description": "Given the `root` of a binary tree, flatten the tree into a \"linked list\":\n\n- The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.", "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100",
     "example_input": "root = [1,2,5,3,4,null,6]", "example_output": "[1,null,2,null,3,null,4,null,5,null,6]", "example_explanation": "Tree flattened to pre-order linked list.",
     "hints": "Process right subtree first, then left.\nKeep track of the previous node.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,5,3,4,null,6]", "output": "[1,null,2,null,3,null,4,null,5,null,6]", "is_sample": True, "explanation": "Flattened"},
                    {"input": "root = []", "output": "[]", "is_sample": True, "explanation": "Empty tree"},
                    {"input": "root = [0]", "output": "[0]", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def flatten(self, root: TreeNode) -> None:\n        pass", "solution": "class Solution:\n    def __init__(self): self.prev = None\n    def flatten(self, root):\n        if not root: return\n        self.flatten(root.right)\n        self.flatten(root.left)\n        root.right = self.prev\n        root.left = None\n        self.prev = root"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void flatten(TreeNode* root) {}\n};", "solution": "class Solution {\n    TreeNode* prev=nullptr;\npublic:\n    void flatten(TreeNode* root) {\n        if(!root) return;\n        flatten(root->right);\n        flatten(root->left);\n        root->right=prev; root->left=nullptr; prev=root;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void flatten(TreeNode root) {}\n}", "solution": "class Solution {\n    TreeNode prev=null;\n    public void flatten(TreeNode root) {\n        if(root==null) return;\n        flatten(root.right); flatten(root.left);\n        root.right=prev; root.left=null; prev=root;\n    }\n}"},
         "javascript": {"starter": "var flatten = function(root) {\n};", "solution": "var flatten = function(root) {\n    let prev=null;\n    const f = n => {\n        if(!n) return;\n        f(n.right); f(n.left);\n        n.right=prev; n.left=null; prev=n;\n    };\n    f(root);\n};"},
         "c": {"starter": "void flatten(struct TreeNode* root) {}", "solution": "struct TreeNode* prev=NULL;\nvoid flatten(struct TreeNode* root) {\n    if(!root) return;\n    flatten(root->right); flatten(root->left);\n    root->right=prev; root->left=NULL; prev=root;\n}"},
     }},
    {"number": 124, "title": "Binary Tree Maximum Path Sum", "difficulty": "hard", "topics": ["Trees", "Dynamic Programming", "Recursion"], "companies": ["Meta", "Google", "Amazon"],
     "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the maximum path sum of any non-empty path.", "constraints": "The number of nodes in the tree is in the range [1, 3 * 10^4].\n-1000 <= Node.val <= 1000",
     "example_input": "root = [-10,9,20,null,null,15,7]", "example_output": "42", "example_explanation": "Path 15 → 20 → 7 = 42.",
     "hints": "At each node, max gain is node.val + max(left, right).\nGlobally track max of node.val + left + right.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,3]", "output": "6", "is_sample": True, "explanation": "2+1+3=6"},
                    {"input": "root = [-10,9,20,null,null,15,7]", "output": "42", "is_sample": True, "explanation": "15+20+7=42"},
                    {"input": "root = [-3]", "output": "-3", "is_sample": False, "explanation": "Negative value"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        pass", "solution": "class Solution:\n    def maxPathSum(self, root):\n        self.res = float('-inf')\n        def gain(node):\n            if not node: return 0\n            l = max(gain(node.left), 0)\n            r = max(gain(node.right), 0)\n            self.res = max(self.res, node.val + l + r)\n            return node.val + max(l, r)\n        gain(root)\n        return self.res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxPathSum(TreeNode* root) { return 0; }\n};", "solution": "class Solution {\n    int res=INT_MIN;\n    int gain(TreeNode* n){\n        if(!n) return 0;\n        int l=max(gain(n->left),0),r=max(gain(n->right),0);\n        res=max(res,n->val+l+r);\n        return n->val+max(l,r);\n    }\npublic:\n    int maxPathSum(TreeNode* root){gain(root);return res;}\n};"},
         "java": {"starter": "class Solution {\n    public int maxPathSum(TreeNode root) { return 0; }\n}", "solution": "class Solution {\n    int res=Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root){gain(root);return res;}\n    int gain(TreeNode n){\n        if(n==null) return 0;\n        int l=Math.max(gain(n.left),0),r=Math.max(gain(n.right),0);\n        res=Math.max(res,n.val+l+r);\n        return n.val+Math.max(l,r);\n    }\n}"},
         "javascript": {"starter": "var maxPathSum = function(root) {\n};", "solution": "var maxPathSum = function(root) {\n    let res=-Infinity;\n    const gain = n => {\n        if(!n) return 0;\n        const l=Math.max(gain(n.left),0),r=Math.max(gain(n.right),0);\n        res=Math.max(res,n.val+l+r);\n        return n.val+Math.max(l,r);\n    };\n    gain(root); return res;\n};"},
         "c": {"starter": "int maxPathSum(struct TreeNode* root) { return 0; }", "solution": "int res;\nint gain(struct TreeNode* n){\n    if(!n) return 0;\n    int l=gain(n->left); if(l<0)l=0;\n    int r=gain(n->right); if(r<0)r=0;\n    int sum=n->val+l+r; if(sum>res)res=sum;\n    return n->val+(l>r?l:r);\n}\nint maxPathSum(struct TreeNode* root){res=root->val;gain(root);return res;}"},
     }},
    {"number": 297, "title": "Serialize and Deserialize Binary Tree", "difficulty": "hard", "topics": ["Trees", "Strings"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
     "constraints": "The number of nodes in the tree is in the range [0, 10^4].\n-1000 <= Node.val <= 1000", "example_input": "root = [1,2,3,null,null,4,5]", "example_output": "[1,2,3,null,null,4,5]",
     "example_explanation": "Tree serialized and deserialized correctly.", "hints": "Use preorder traversal with null markers.\nReconstruct using a queue/iterator.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,3,null,null,4,5]", "output": "[1,2,3,null,null,4,5]", "is_sample": True, "explanation": "Round-trip"},
                    {"input": "root = []", "output": "[]", "is_sample": True, "explanation": "Empty tree"},
                    {"input": "root = [1]", "output": "[1]", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Codec:\n    def serialize(self, root: TreeNode) -> str:\n        pass\n    def deserialize(self, data: str) -> TreeNode:\n        pass", "solution": "class Codec:\n    def serialize(self, root):\n        vals = []\n        def dfs(node):\n            if not node: vals.append('#'); return\n            vals.append(str(node.val))\n            dfs(node.left); dfs(node.right)\n        dfs(root)\n        return ','.join(vals)\n    def deserialize(self, data):\n        vals = iter(data.split(','))\n        def dfs():\n            v = next(vals)\n            if v == '#': return None\n            node = TreeNode(int(v))\n            node.left = dfs(); node.right = dfs()\n            return node\n        return dfs()"},
         "cpp17": {"starter": "class Codec {\npublic:\n    string serialize(TreeNode* root) { return \"\"; }\n    TreeNode* deserialize(string data) { return nullptr; }\n};", "solution": "class Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if(!root) return \"#\";\n        return to_string(root->val)+\",\"+serialize(root->left)+\",\"+serialize(root->right);\n    }\n    TreeNode* deserialize(string data) {\n        istringstream ss(data); return dfs(ss);\n    }\n    TreeNode* dfs(istringstream& ss) {\n        string v; getline(ss, v, ',');\n        if(v==\"#\") return nullptr;\n        TreeNode* n=new TreeNode(stoi(v));\n        n->left=dfs(ss); n->right=dfs(ss);\n        return n;\n    }\n};"},
         "java": {"starter": "class Codec {\n    public String serialize(TreeNode root) { return \"\"; }\n    public TreeNode deserialize(String data) { return null; }\n}", "solution": "class Codec {\n    public String serialize(TreeNode root) {\n        if(root==null) return \"#\";\n        return root.val+\",\"+serialize(root.left)+\",\"+serialize(root.right);\n    }\n    public TreeNode deserialize(String data) {\n        Queue<String> q=new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return dfs(q);\n    }\n    TreeNode dfs(Queue<String> q) {\n        String v=q.poll();\n        if(v.equals(\"#\")) return null;\n        TreeNode n=new TreeNode(Integer.parseInt(v));\n        n.left=dfs(q); n.right=dfs(q);\n        return n;\n    }\n}"},
         "javascript": {"starter": "var serialize = function(root) {\n};\nvar deserialize = function(data) {\n};", "solution": "var serialize = function(root) {\n    if(!root) return '#';\n    return root.val+','+serialize(root.left)+','+serialize(root.right);\n};\nvar deserialize = function(data) {\n    const vals=data.split(','); let i=0;\n    const dfs = () => {\n        if(vals[i]==='#'){i++;return null;}\n        const n={val:parseInt(vals[i++]),left:null,right:null};\n        n.left=dfs(); n.right=dfs();\n        return n;\n    };\n    return dfs();\n};"},
         "c": {"starter": "char* serialize(struct TreeNode* root) { return \"\"; }\nstruct TreeNode* deserialize(char* data) { return NULL; }", "solution": "char buf[100000]; int bpos;\nvoid ser(struct TreeNode* n) {\n    if(!n) { bpos+=sprintf(buf+bpos,\"#,\"); return; }\n    bpos+=sprintf(buf+bpos,\"%d,\",n->val);\n    ser(n->left); ser(n->right);\n}\nchar* serialize(struct TreeNode* root) { bpos=0; ser(root); return strdup(buf); }\nstruct TreeNode* des(char** s) {\n    if(**s=='#') { *s+=2; return NULL; }\n    int v=0,neg=0; if(**s=='-'){neg=1;(*s)++;}\n    while(**s!=','){v=v*10+(**s-'0');(*s)++;} (*s)++;\n    struct TreeNode* n=malloc(sizeof(struct TreeNode));\n    n->val=neg?-v:v; n->left=des(s); n->right=des(s);\n    return n;\n}\nstruct TreeNode* deserialize(char* data) { return des(&data); }"},
     }},
    {"number": 295, "title": "Find Median from Data Stream", "difficulty": "hard", "topics": ["Heap", "Sorting"], "companies": ["Amazon", "Google", "Meta"],
     "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the MedianFinder object.\n- `void addNum(int num)` adds the integer num from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.",
     "constraints": "-10^5 <= num <= 10^5\nThere will be at least one element before calling findMedian.\nAt most 5 * 10^4 calls to addNum and findMedian.", "example_input": '["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]\n[[],[1],[2],[],[3],[]]', "example_output": "[null,null,null,1.5,null,2.0]",
     "example_explanation": "After [1,2] median is 1.5. After [1,2,3] median is 2.", "hints": "Use two heaps: max-heap for lower half, min-heap for upper half.\nBalance sizes to differ by at most 1.", "time_complexity": "O(log n)", "space_complexity": "O(n)",
     "test_cases": [{"input": '["MedianFinder","addNum","findMedian","addNum","findMedian"]\n[[],[1],[],[2],[]]', "output": "[null,null,1.0,null,1.5]", "is_sample": True, "explanation": "Median tracking"},
                    {"input": '["MedianFinder","addNum","addNum","addNum","findMedian"]\n[[],[1],[2],[3],[]]', "output": "[null,null,null,null,2.0]", "is_sample": True, "explanation": "Median of 3 numbers"},
                    {"input": '["MedianFinder","addNum","findMedian"]\n[[],[5],[]]', "output": "[null,null,5.0]", "is_sample": False, "explanation": "Single number"}],
     "templates": {
         "python3": {"starter": "class MedianFinder:\n    def __init__(self):\n        pass\n    def addNum(self, num: int) -> None:\n        pass\n    def findMedian(self) -> float:\n        pass", "solution": "import heapq\nclass MedianFinder:\n    def __init__(self):\n        self.lo = []  # max heap (negated)\n        self.hi = []  # min heap\n    def addNum(self, num):\n        heapq.heappush(self.lo, -num)\n        heapq.heappush(self.hi, -heapq.heappop(self.lo))\n        if len(self.hi) > len(self.lo):\n            heapq.heappush(self.lo, -heapq.heappop(self.hi))\n    def findMedian(self):\n        if len(self.lo) > len(self.hi):\n            return -self.lo[0]\n        return (-self.lo[0] + self.hi[0]) / 2"},
         "cpp17": {"starter": "class MedianFinder {\npublic:\n    MedianFinder() {}\n    void addNum(int num) {}\n    double findMedian() { return 0; }\n};", "solution": "class MedianFinder {\n    priority_queue<int> lo;\n    priority_queue<int,vector<int>,greater<int>> hi;\npublic:\n    void addNum(int n) {\n        lo.push(n); hi.push(lo.top()); lo.pop();\n        if(hi.size()>lo.size()){lo.push(hi.top());hi.pop();}\n    }\n    double findMedian() {\n        return lo.size()>hi.size()?lo.top():(lo.top()+hi.top())/2.0;\n    }\n};"},
         "java": {"starter": "class MedianFinder {\n    public MedianFinder() {}\n    public void addNum(int num) {}\n    public double findMedian() { return 0; }\n}", "solution": "class MedianFinder {\n    PriorityQueue<Integer> lo=new PriorityQueue<>(Collections.reverseOrder());\n    PriorityQueue<Integer> hi=new PriorityQueue<>();\n    public void addNum(int n) {\n        lo.add(n); hi.add(lo.poll());\n        if(hi.size()>lo.size()) lo.add(hi.poll());\n    }\n    public double findMedian() {\n        return lo.size()>hi.size()?lo.peek():(lo.peek()+hi.peek())/2.0;\n    }\n}"},
         "javascript": {"starter": "var MedianFinder = function() {\n};\nMedianFinder.prototype.addNum = function(num) {};\nMedianFinder.prototype.findMedian = function() {};", "solution": "// Simplified using sorted array insertion\nvar MedianFinder = function() { this.arr=[]; };\nMedianFinder.prototype.addNum = function(num) {\n    let lo=0,hi=this.arr.length;\n    while(lo<hi){const m=(lo+hi)>>1;if(this.arr[m]<num)lo=m+1;else hi=m;}\n    this.arr.splice(lo,0,num);\n};\nMedianFinder.prototype.findMedian = function() {\n    const n=this.arr.length,m=n>>1;\n    return n%2?this.arr[m]:(this.arr[m-1]+this.arr[m])/2;\n};"},
         "c": {"starter": "typedef struct { int dummy; } MedianFinder;\nMedianFinder* medianFinderCreate() { return NULL; }\nvoid medianFinderAddNum(MedianFinder* obj, int num) {}\ndouble medianFinderFindMedian(MedianFinder* obj) { return 0; }", "solution": "typedef struct { int arr[50000]; int sz; } MedianFinder;\nMedianFinder* medianFinderCreate() { MedianFinder* m=calloc(1,sizeof(MedianFinder)); return m; }\nvoid medianFinderAddNum(MedianFinder* m, int num) {\n    int i=m->sz-1;\n    while(i>=0&&m->arr[i]>num){m->arr[i+1]=m->arr[i];i--;}\n    m->arr[i+1]=num; m->sz++;\n}\ndouble medianFinderFindMedian(MedianFinder* m) {\n    int mid=m->sz/2;\n    return m->sz%2?m->arr[mid]:(m->arr[mid-1]+m->arr[mid])/2.0;\n}"},
     }},
    {"number": 84, "title": "Largest Rectangle in Histogram", "difficulty": "hard", "topics": ["Arrays", "Stack"], "companies": ["Amazon", "Google", "Microsoft"],
     "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.",
     "constraints": "1 <= heights.length <= 10^5\n0 <= heights[i] <= 10^4", "example_input": "heights = [2,1,5,6,2,3]", "example_output": "10",
     "example_explanation": "Rectangle of height 5 and width 2 = 10.", "hints": "Use a monotonic stack.\nFor each bar, find how far left and right it can extend.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "heights = [2,1,5,6,2,3]", "output": "10", "is_sample": True, "explanation": "Max rectangle area"},
                    {"input": "heights = [2,4]", "output": "4", "is_sample": True, "explanation": "Min(2,4)*2=4"},
                    {"input": "heights = [1]", "output": "1", "is_sample": False, "explanation": "Single bar"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def largestRectangleArea(self, heights: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def largestRectangleArea(self, heights):\n        stack = []\n        res = 0\n        heights.append(0)\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n            stack.append(i)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& h) {\n        h.push_back(0); stack<int> st; int res=0;\n        for(int i=0;i<h.size();i++){\n            while(!st.empty()&&h[st.top()]>h[i]){\n                int ht=h[st.top()];st.pop();\n                int w=st.empty()?i:i-st.top()-1;\n                res=max(res,ht*w);\n            }\n            st.push(i);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int largestRectangleArea(int[] heights) { return 0; }\n}", "solution": "class Solution {\n    public int largestRectangleArea(int[] h) {\n        Stack<Integer> st=new Stack<>(); int res=0;\n        for(int i=0;i<=h.length;i++){\n            int cur=i==h.length?0:h[i];\n            while(!st.isEmpty()&&h[st.peek()]>cur){\n                int ht=h[st.pop()];\n                int w=st.isEmpty()?i:i-st.peek()-1;\n                res=Math.max(res,ht*w);\n            }\n            st.push(i);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var largestRectangleArea = function(heights) {\n};", "solution": "var largestRectangleArea = function(h) {\n    h.push(0); const st=[]; let res=0;\n    for(let i=0;i<h.length;i++){\n        while(st.length&&h[st[st.length-1]]>h[i]){\n            const ht=h[st.pop()];\n            const w=st.length?i-st[st.length-1]-1:i;\n            res=Math.max(res,ht*w);\n        }\n        st.push(i);\n    }\n    return res;\n};"},
         "c": {"starter": "int largestRectangleArea(int* h, int n) { return 0; }", "solution": "int largestRectangleArea(int* h, int n) {\n    int st[100001],top=-1,res=0;\n    for(int i=0;i<=n;i++){\n        int cur=i==n?0:h[i];\n        while(top>=0&&h[st[top]]>cur){\n            int ht=h[st[top--]];\n            int w=top<0?i:i-st[top]-1;\n            if(ht*w>res) res=ht*w;\n        }\n        st[++top]=i;\n    }\n    return res;\n}"},
     }},
]
