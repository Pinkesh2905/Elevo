"""Problems 41-50."""
PROBLEMS = [
    {"number": 101, "title": "Symmetric Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Amazon", "Microsoft", "Bloomberg"],
     "description": "Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
     "constraints": "The number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100", "example_input": "root = [1,2,2,3,4,4,3]", "example_output": "true",
     "example_explanation": "The tree is symmetric.", "hints": "Compare left subtree with right subtree recursively.\nLeft's left should match right's right.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,2,3,4,4,3]", "output": "true", "is_sample": True, "explanation": "Mirror symmetric"},
                    {"input": "root = [1,2,2,null,3,null,3]", "output": "false", "is_sample": True, "explanation": "Not symmetric"},
                    {"input": "root = [1]", "output": "true", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        pass", "solution": "class Solution:\n    def isSymmetric(self, root):\n        def mirror(a, b):\n            if not a and not b: return True\n            if not a or not b: return False\n            return a.val == b.val and mirror(a.left, b.right) and mirror(a.right, b.left)\n        return mirror(root.left, root.right)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool mirror(TreeNode* a, TreeNode* b) {\n        if(!a&&!b) return true; if(!a||!b) return false;\n        return a->val==b->val && mirror(a->left,b->right) && mirror(a->right,b->left);\n    }\n    bool isSymmetric(TreeNode* root) { return mirror(root->left, root->right); }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isSymmetric(TreeNode root) { return false; }\n}", "solution": "class Solution {\n    public boolean isSymmetric(TreeNode root) { return mirror(root.left, root.right); }\n    boolean mirror(TreeNode a, TreeNode b) {\n        if(a==null&&b==null) return true; if(a==null||b==null) return false;\n        return a.val==b.val && mirror(a.left,b.right) && mirror(a.right,b.left);\n    }\n}"},
         "javascript": {"starter": "var isSymmetric = function(root) {\n};", "solution": "var isSymmetric = function(root) {\n    const mirror = (a, b) => {\n        if(!a&&!b) return true; if(!a||!b) return false;\n        return a.val===b.val && mirror(a.left,b.right) && mirror(a.right,b.left);\n    };\n    return mirror(root.left, root.right);\n};"},
         "c": {"starter": "bool isSymmetric(struct TreeNode* root) { return false; }", "solution": "bool mirror(struct TreeNode* a, struct TreeNode* b) {\n    if(!a&&!b) return true; if(!a||!b) return false;\n    return a->val==b->val && mirror(a->left,b->right) && mirror(a->right,b->left);\n}\nbool isSymmetric(struct TreeNode* root) { return mirror(root->left, root->right); }"},
     }},
    {"number": 104, "title": "Maximum Depth of Binary Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Amazon", "Google", "Meta"],
     "description": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
     "constraints": "The number of nodes in the tree is in the range [0, 10^4].\n-100 <= Node.val <= 100", "example_input": "root = [3,9,20,null,null,15,7]", "example_output": "3",
     "example_explanation": "Depth is 3.", "hints": "Use recursion: depth = 1 + max(left, right).\nBase case: null node has depth 0.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [3,9,20,null,null,15,7]", "output": "3", "is_sample": True, "explanation": "3 levels"},
                    {"input": "root = [1,null,2]", "output": "2", "is_sample": True, "explanation": "2 levels"},
                    {"input": "root = []", "output": "0", "is_sample": False, "explanation": "Empty tree"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        pass", "solution": "class Solution:\n    def maxDepth(self, root):\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int maxDepth(TreeNode root) { return 0; }\n}", "solution": "class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}"},
         "javascript": {"starter": "var maxDepth = function(root) {\n};", "solution": "var maxDepth = function(root) {\n    if(!root) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n};"},
         "c": {"starter": "int maxDepth(struct TreeNode* root) { return 0; }", "solution": "int maxDepth(struct TreeNode* root) {\n    if(!root) return 0;\n    int l = maxDepth(root->left), r = maxDepth(root->right);\n    return 1 + (l > r ? l : r);\n}"},
     }},
    {"number": 121, "title": "Best Time to Buy and Sell Stock", "difficulty": "easy", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Google", "Meta"],
     "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.",
     "constraints": "1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^4", "example_input": "prices = [7,1,5,3,6,4]", "example_output": "5",
     "example_explanation": "Buy on day 2 (price=1) and sell on day 5 (price=6), profit = 5.", "hints": "Track the minimum price so far.\nFor each day, compute profit = current - minPrice.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "prices = [7,1,5,3,6,4]", "output": "5", "is_sample": True, "explanation": "Buy at 1, sell at 6"},
                    {"input": "prices = [7,6,4,3,1]", "output": "0", "is_sample": True, "explanation": "No profit possible"},
                    {"input": "prices = [2,4,1]", "output": "2", "is_sample": False, "explanation": "Buy at 2, sell at 4"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def maxProfit(self, prices):\n        minP = float('inf')\n        maxP = 0\n        for p in prices:\n            minP = min(minP, p)\n            maxP = max(maxP, p - minP)\n        return maxP"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int minP=INT_MAX, maxP=0;\n        for(int p:prices){minP=min(minP,p);maxP=max(maxP,p-minP);}\n        return maxP;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int maxProfit(int[] prices) { return 0; }\n}", "solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        int minP=Integer.MAX_VALUE, maxP=0;\n        for(int p:prices){minP=Math.min(minP,p);maxP=Math.max(maxP,p-minP);}\n        return maxP;\n    }\n}"},
         "javascript": {"starter": "var maxProfit = function(prices) {\n};", "solution": "var maxProfit = function(prices) {\n    let minP=Infinity, maxP=0;\n    for(const p of prices){minP=Math.min(minP,p);maxP=Math.max(maxP,p-minP);}\n    return maxP;\n};"},
         "c": {"starter": "int maxProfit(int* prices, int n) { return 0; }", "solution": "int maxProfit(int* prices, int n) {\n    int minP=prices[0], maxP=0;\n    for(int i=1;i<n;i++){if(prices[i]<minP)minP=prices[i];else if(prices[i]-minP>maxP)maxP=prices[i]-minP;}\n    return maxP;\n}"},
     }},
    {"number": 125, "title": "Valid Palindrome", "difficulty": "easy", "topics": ["Strings", "Two Pointers"], "companies": ["Meta", "Amazon", "Microsoft"],
     "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
     "constraints": "1 <= s.length <= 2 * 10^5\ns consists only of printable ASCII characters.", "example_input": 's = "A man, a plan, a canal: Panama"', "example_output": "true",
     "example_explanation": '"amanaplanacanalpanama" is a palindrome.', "hints": "Use two pointers from both ends.\nSkip non-alphanumeric characters.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": 's = "A man, a plan, a canal: Panama"', "output": "true", "is_sample": True, "explanation": "Is a palindrome"},
                    {"input": 's = "race a car"', "output": "false", "is_sample": True, "explanation": "Not a palindrome"},
                    {"input": 's = " "', "output": "true", "is_sample": False, "explanation": "Empty is palindrome"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        pass", "solution": "class Solution:\n    def isPalindrome(self, s):\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum(): l += 1\n            while l < r and not s[r].isalnum(): r -= 1\n            if s[l].lower() != s[r].lower(): return False\n            l += 1; r -= 1\n        return True"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isPalindrome(string s) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int l=0,r=s.size()-1;\n        while(l<r){\n            while(l<r&&!isalnum(s[l]))l++;\n            while(l<r&&!isalnum(s[r]))r--;\n            if(tolower(s[l])!=tolower(s[r]))return false;\n            l++;r--;\n        }\n        return true;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isPalindrome(String s) { return false; }\n}", "solution": "class Solution {\n    public boolean isPalindrome(String s) {\n        int l=0,r=s.length()-1;\n        while(l<r){\n            while(l<r&&!Character.isLetterOrDigit(s.charAt(l)))l++;\n            while(l<r&&!Character.isLetterOrDigit(s.charAt(r)))r--;\n            if(Character.toLowerCase(s.charAt(l))!=Character.toLowerCase(s.charAt(r)))return false;\n            l++;r--;\n        }\n        return true;\n    }\n}"},
         "javascript": {"starter": "var isPalindrome = function(s) {\n};", "solution": "var isPalindrome = function(s) {\n    const clean = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return clean === clean.split('').reverse().join('');\n};"},
         "c": {"starter": "#include <ctype.h>\nbool isPalindrome(char* s) { return false; }", "solution": "bool isPalindrome(char* s) {\n    int l=0,r=strlen(s)-1;\n    while(l<r){\n        while(l<r&&!isalnum(s[l]))l++;\n        while(l<r&&!isalnum(s[r]))r--;\n        if(tolower(s[l])!=tolower(s[r]))return false;\n        l++;r--;\n    }\n    return true;\n}"},
     }},
    {"number": 128, "title": "Longest Consecutive Sequence", "difficulty": "medium", "topics": ["Arrays", "Hash Table"], "companies": ["Google", "Amazon", "Meta"],
     "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in `O(n)` time.",
     "constraints": "0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9", "example_input": "nums = [100,4,200,1,3,2]", "example_output": "4",
     "example_explanation": "The longest consecutive sequence is [1,2,3,4]. Length is 4.", "hints": "Use a HashSet for O(1) lookups.\nOnly start counting from numbers that don't have num-1 in the set.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [100,4,200,1,3,2]", "output": "4", "is_sample": True, "explanation": "Sequence: 1,2,3,4"},
                    {"input": "nums = [0,3,7,2,5,8,4,6,0,1]", "output": "9", "is_sample": True, "explanation": "Sequence: 0-8"},
                    {"input": "nums = []", "output": "0", "is_sample": False, "explanation": "Empty array"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def longestConsecutive(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def longestConsecutive(self, nums):\n        s = set(nums)\n        best = 0\n        for n in s:\n            if n - 1 not in s:\n                cur = n\n                while cur + 1 in s: cur += 1\n                best = max(best, cur - n + 1)\n        return best"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        int best=0;\n        for(int n:s){\n            if(!s.count(n-1)){\n                int cur=n;\n                while(s.count(cur+1))cur++;\n                best=max(best,cur-n+1);\n            }\n        }\n        return best;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int longestConsecutive(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> s = new HashSet<>(); for(int n:nums) s.add(n);\n        int best=0;\n        for(int n:s){\n            if(!s.contains(n-1)){\n                int cur=n;\n                while(s.contains(cur+1))cur++;\n                best=Math.max(best,cur-n+1);\n            }\n        }\n        return best;\n    }\n}"},
         "javascript": {"starter": "var longestConsecutive = function(nums) {\n};", "solution": "var longestConsecutive = function(nums) {\n    const s = new Set(nums);\n    let best = 0;\n    for(const n of s){\n        if(!s.has(n-1)){\n            let cur=n;\n            while(s.has(cur+1))cur++;\n            best=Math.max(best,cur-n+1);\n        }\n    }\n    return best;\n};"},
         "c": {"starter": "int longestConsecutive(int* nums, int n) { return 0; }", "solution": "int cmp(const void*a,const void*b){return *(int*)a-*(int*)b;}\nint longestConsecutive(int* nums, int n) {\n    if(!n) return 0;\n    qsort(nums,n,sizeof(int),cmp);\n    int best=1,cur=1;\n    for(int i=1;i<n;i++){\n        if(nums[i]==nums[i-1]) continue;\n        if(nums[i]==nums[i-1]+1) cur++;\n        else cur=1;\n        if(cur>best) best=cur;\n    }\n    return best;\n}"},
     }},
    {"number": 136, "title": "Single Number", "difficulty": "easy", "topics": ["Arrays", "Bit Manipulation"], "companies": ["Amazon", "Google", "Apple"],
     "description": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
     "constraints": "1 <= nums.length <= 3 * 10^4\n-3 * 10^4 <= nums[i] <= 3 * 10^4\nEach element appears twice except for one element which appears only once.", "example_input": "nums = [2,2,1]", "example_output": "1",
     "example_explanation": "1 appears only once.", "hints": "XOR of a number with itself is 0.\nXOR all numbers together.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [2,2,1]", "output": "1", "is_sample": True, "explanation": "1 is the single number"},
                    {"input": "nums = [4,1,2,1,2]", "output": "4", "is_sample": True, "explanation": "4 is the single number"},
                    {"input": "nums = [1]", "output": "1", "is_sample": False, "explanation": "Only one element"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def singleNumber(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def singleNumber(self, nums):\n        res = 0\n        for n in nums: res ^= n\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res=0; for(int n:nums) res^=n; return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int singleNumber(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        int res=0; for(int n:nums) res^=n; return res;\n    }\n}"},
         "javascript": {"starter": "var singleNumber = function(nums) {\n};", "solution": "var singleNumber = function(nums) {\n    return nums.reduce((a,b)=>a^b, 0);\n};"},
         "c": {"starter": "int singleNumber(int* nums, int n) { return 0; }", "solution": "int singleNumber(int* nums, int n) {\n    int res=0; for(int i=0;i<n;i++) res^=nums[i]; return res;\n}"},
     }},
    {"number": 141, "title": "Linked List Cycle", "difficulty": "easy", "topics": ["Linked List", "Two Pointers"], "companies": ["Amazon", "Microsoft", "Bloomberg"],
     "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.",
     "constraints": "The number of the nodes in the list is in the range [0, 10^4].\n-10^5 <= Node.val <= 10^5", "example_input": "head = [3,2,0,-4], pos = 1", "example_output": "true",
     "example_explanation": "There is a cycle connecting tail to node index 1.", "hints": "Use Floyd's cycle detection (tortoise and hare).\nSlow moves 1 step, fast moves 2 steps.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "head = [3,2,0,-4]\npos = 1", "output": "true", "is_sample": True, "explanation": "Cycle at index 1"},
                    {"input": "head = [1,2]\npos = 0", "output": "true", "is_sample": True, "explanation": "Cycle at index 0"},
                    {"input": "head = [1]\npos = -1", "output": "false", "is_sample": False, "explanation": "No cycle"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        pass", "solution": "class Solution:\n    def hasCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast: return True\n        return False"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        while(fast&&fast->next){\n            slow=slow->next; fast=fast->next->next;\n            if(slow==fast) return true;\n        }\n        return false;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean hasCycle(ListNode head) { return false; }\n}", "solution": "class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow=head,fast=head;\n        while(fast!=null&&fast.next!=null){\n            slow=slow.next; fast=fast.next.next;\n            if(slow==fast) return true;\n        }\n        return false;\n    }\n}"},
         "javascript": {"starter": "var hasCycle = function(head) {\n};", "solution": "var hasCycle = function(head) {\n    let slow=head,fast=head;\n    while(fast&&fast.next){\n        slow=slow.next; fast=fast.next.next;\n        if(slow===fast) return true;\n    }\n    return false;\n};"},
         "c": {"starter": "bool hasCycle(struct ListNode *head) { return false; }", "solution": "bool hasCycle(struct ListNode *head) {\n    struct ListNode *slow=head,*fast=head;\n    while(fast&&fast->next){\n        slow=slow->next; fast=fast->next->next;\n        if(slow==fast) return true;\n    }\n    return false;\n}"},
     }},
    {"number": 146, "title": "LRU Cache", "difficulty": "medium", "topics": ["Hash Table", "Linked List"], "companies": ["Amazon", "Google", "Meta"],
     "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the `LRUCache` class:\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key.",
     "constraints": "1 <= capacity <= 3000\n0 <= key <= 10^4\n0 <= value <= 10^5\nAt most 2 * 10^5 calls will be made to get and put.", "example_input": '["LRUCache","put","put","get","put","get","put","get","get","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]', "example_output": "[null,null,null,1,null,-1,null,-1,3,4]",
     "example_explanation": "LRU eviction in action.", "hints": "Use a hash map + doubly linked list.\nHash map gives O(1) access, linked list maintains order.", "time_complexity": "O(1)", "space_complexity": "O(capacity)",
     "test_cases": [{"input": '["LRUCache","put","put","get","put","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2]]', "output": "[null,null,null,1,null,-1]", "is_sample": True, "explanation": "Key 2 evicted when 3 added"},
                    {"input": '["LRUCache","put","get"]\n[[1],[2,1],[2]]', "output": "[null,null,1]", "is_sample": True, "explanation": "Simple get after put"},
                    {"input": '["LRUCache","put","put","put","get"]\n[[2],[1,1],[2,2],[3,3],[1]]', "output": "[null,null,null,null,-1]", "is_sample": False, "explanation": "Key 1 evicted"}],
     "templates": {
         "python3": {"starter": "class LRUCache:\n    def __init__(self, capacity: int):\n        pass\n    def get(self, key: int) -> int:\n        pass\n    def put(self, key: int, value: int) -> None:\n        pass", "solution": "from collections import OrderedDict\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.cap = capacity\n    def get(self, key):\n        if key not in self.cache: return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    def put(self, key, value):\n        if key in self.cache: self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)"},
         "cpp17": {"starter": "class LRUCache {\npublic:\n    LRUCache(int capacity) {}\n    int get(int key) { return -1; }\n    void put(int key, int value) {}\n};", "solution": "class LRUCache {\n    int cap;\n    list<pair<int,int>> dll;\n    unordered_map<int,list<pair<int,int>>::iterator> m;\npublic:\n    LRUCache(int capacity) : cap(capacity) {}\n    int get(int key) {\n        if(m.find(key)==m.end()) return -1;\n        dll.splice(dll.end(),dll,m[key]);\n        return m[key]->second;\n    }\n    void put(int key, int value) {\n        if(m.find(key)!=m.end()){m[key]->second=value;dll.splice(dll.end(),dll,m[key]);return;}\n        if(dll.size()==cap){m.erase(dll.front().first);dll.pop_front();}\n        dll.push_back({key,value}); m[key]=prev(dll.end());\n    }\n};"},
         "java": {"starter": "class LRUCache {\n    public LRUCache(int capacity) {}\n    public int get(int key) { return -1; }\n    public void put(int key, int value) {}\n}", "solution": "class LRUCache extends LinkedHashMap<Integer, Integer> {\n    int cap;\n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true); cap = capacity;\n    }\n    public int get(int key) { return super.getOrDefault(key, -1); }\n    public void put(int key, int value) { super.put(key, value); }\n    protected boolean removeEldestEntry(Map.Entry e) { return size() > cap; }\n}"},
         "javascript": {"starter": "var LRUCache = function(capacity) {\n};\nLRUCache.prototype.get = function(key) {\n};\nLRUCache.prototype.put = function(key, value) {\n};", "solution": "var LRUCache = function(capacity) {\n    this.cap = capacity;\n    this.cache = new Map();\n};\nLRUCache.prototype.get = function(key) {\n    if(!this.cache.has(key)) return -1;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n};\nLRUCache.prototype.put = function(key, value) {\n    if(this.cache.has(key)) this.cache.delete(key);\n    this.cache.set(key, value);\n    if(this.cache.size > this.cap) this.cache.delete(this.cache.keys().next().value);\n};"},
         "c": {"starter": "typedef struct { int dummy; } LRUCache;\nLRUCache* lRUCacheCreate(int cap) { return NULL; }\nint lRUCacheGet(LRUCache* obj, int key) { return -1; }\nvoid lRUCachePut(LRUCache* obj, int key, int value) {}", "solution": "// C implementation uses hash table + doubly linked list\ntypedef struct Node { int key,val; struct Node *prev,*next; } Node;\ntypedef struct { Node *head,*tail; Node* map[10001]; int cap,size; } LRUCache;\nLRUCache* lRUCacheCreate(int cap) {\n    LRUCache* c=calloc(1,sizeof(LRUCache)); c->cap=cap;\n    c->head=calloc(1,sizeof(Node)); c->tail=calloc(1,sizeof(Node));\n    c->head->next=c->tail; c->tail->prev=c->head;\n    return c;\n}\nvoid removeNode(Node* n){n->prev->next=n->next;n->next->prev=n->prev;}\nvoid addToEnd(LRUCache* c,Node* n){n->prev=c->tail->prev;n->next=c->tail;c->tail->prev->next=n;c->tail->prev=n;}\nint lRUCacheGet(LRUCache* c, int key) {\n    if(!c->map[key]) return -1;\n    removeNode(c->map[key]); addToEnd(c,c->map[key]);\n    return c->map[key]->val;\n}\nvoid lRUCachePut(LRUCache* c, int key, int val) {\n    if(c->map[key]){c->map[key]->val=val;removeNode(c->map[key]);addToEnd(c,c->map[key]);return;}\n    Node* n=calloc(1,sizeof(Node));n->key=key;n->val=val;\n    c->map[key]=n; addToEnd(c,n); c->size++;\n    if(c->size>c->cap){Node* lru=c->head->next;removeNode(lru);c->map[lru->key]=NULL;free(lru);c->size--;}\n}"},
     }},
    {"number": 155, "title": "Min Stack", "difficulty": "medium", "topics": ["Stack"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n- `MinStack()` initializes the stack object.\n- `void push(int val)` pushes the element val onto the stack.\n- `void pop()` removes the element on the top of the stack.\n- `int top()` gets the top element of the stack.\n- `int getMin()` retrieves the minimum element in the stack.",
     "constraints": "-2^31 <= val <= 2^31 - 1\nMethods pop, top and getMin operations will always be called on non-empty stacks.\nAt most 3 * 10^4 calls will be made to push, pop, top, and getMin.", "example_input": '["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]', "example_output": "[null,null,null,null,-3,null,0,-2]",
     "example_explanation": "Tracks minimum as elements are pushed/popped.", "hints": "Keep a second stack that tracks minimums.\nEach entry stores the minimum at that point.", "time_complexity": "O(1)", "space_complexity": "O(n)",
     "test_cases": [{"input": '["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]', "output": "[null,null,null,null,-3,null,0,-2]", "is_sample": True, "explanation": "Min tracking works"},
                    {"input": '["MinStack","push","push","getMin"]\n[[],[1],[2],[]]', "output": "[null,null,null,1]", "is_sample": True, "explanation": "Min is 1"},
                    {"input": '["MinStack","push","getMin","pop"]\n[[],[5],[],[]]', "output": "[null,null,5,null]", "is_sample": False, "explanation": "Single element"}],
     "templates": {
         "python3": {"starter": "class MinStack:\n    def __init__(self):\n        pass\n    def push(self, val: int) -> None:\n        pass\n    def pop(self) -> None:\n        pass\n    def top(self) -> int:\n        pass\n    def getMin(self) -> int:\n        pass", "solution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    def push(self, val):\n        self.stack.append(val)\n        self.min_stack.append(min(val, self.min_stack[-1] if self.min_stack else val))\n    def pop(self): self.stack.pop(); self.min_stack.pop()\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.min_stack[-1]"},
         "cpp17": {"starter": "class MinStack {\npublic:\n    MinStack() {}\n    void push(int val) {}\n    void pop() {}\n    int top() { return 0; }\n    int getMin() { return 0; }\n};", "solution": "class MinStack {\n    stack<int> st, mn;\npublic:\n    MinStack() {}\n    void push(int val) { st.push(val); mn.push(mn.empty()?val:min(val,mn.top())); }\n    void pop() { st.pop(); mn.pop(); }\n    int top() { return st.top(); }\n    int getMin() { return mn.top(); }\n};"},
         "java": {"starter": "class MinStack {\n    public MinStack() {}\n    public void push(int val) {}\n    public void pop() {}\n    public int top() { return 0; }\n    public int getMin() { return 0; }\n}", "solution": "class MinStack {\n    Stack<int[]> st = new Stack<>();\n    public void push(int val) { st.push(new int[]{val, st.isEmpty()?val:Math.min(val,st.peek()[1])}); }\n    public void pop() { st.pop(); }\n    public int top() { return st.peek()[0]; }\n    public int getMin() { return st.peek()[1]; }\n}"},
         "javascript": {"starter": "var MinStack = function() {\n};\nMinStack.prototype.push = function(val) {};\nMinStack.prototype.pop = function() {};\nMinStack.prototype.top = function() {};\nMinStack.prototype.getMin = function() {};", "solution": "var MinStack = function() { this.st=[]; this.mn=[]; };\nMinStack.prototype.push = function(val) { this.st.push(val); this.mn.push(this.mn.length?Math.min(val,this.mn[this.mn.length-1]):val); };\nMinStack.prototype.pop = function() { this.st.pop(); this.mn.pop(); };\nMinStack.prototype.top = function() { return this.st[this.st.length-1]; };\nMinStack.prototype.getMin = function() { return this.mn[this.mn.length-1]; };"},
         "c": {"starter": "typedef struct { int dummy; } MinStack;\nMinStack* minStackCreate() { return NULL; }\nvoid minStackPush(MinStack* obj, int val) {}\nvoid minStackPop(MinStack* obj) {}\nint minStackTop(MinStack* obj) { return 0; }\nint minStackGetMin(MinStack* obj) { return 0; }", "solution": "typedef struct { int st[30000]; int mn[30000]; int top; } MinStack;\nMinStack* minStackCreate() { MinStack* s=malloc(sizeof(MinStack)); s->top=-1; return s; }\nvoid minStackPush(MinStack* s, int val) { s->top++; s->st[s->top]=val; s->mn[s->top]=s->top==0?val:(val<s->mn[s->top-1]?val:s->mn[s->top-1]); }\nvoid minStackPop(MinStack* s) { s->top--; }\nint minStackTop(MinStack* s) { return s->st[s->top]; }\nint minStackGetMin(MinStack* s) { return s->mn[s->top]; }"},
     }},
    {"number": 169, "title": "Majority Element", "difficulty": "easy", "topics": ["Arrays", "Hash Table", "Sorting"], "companies": ["Amazon", "Google", "Adobe"],
     "description": "Given an array `nums` of size `n`, return the majority element.\n\nThe majority element is the element that appears more than `\u230an / 2\u230b` times. You may assume that the majority element always exists in the array.",
     "constraints": "n == nums.length\n1 <= n <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9", "example_input": "nums = [3,2,3]", "example_output": "3",
     "example_explanation": "3 appears twice (majority).", "hints": "Use Boyer-Moore Voting Algorithm.\nCandidate with most votes wins.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [3,2,3]", "output": "3", "is_sample": True, "explanation": "3 is majority"},
                    {"input": "nums = [2,2,1,1,1,2,2]", "output": "2", "is_sample": True, "explanation": "2 is majority"},
                    {"input": "nums = [1]", "output": "1", "is_sample": False, "explanation": "Single element"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def majorityElement(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def majorityElement(self, nums):\n        count = 0\n        candidate = None\n        for n in nums:\n            if count == 0: candidate = n\n            count += 1 if n == candidate else -1\n        return candidate"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int cnt=0,cand=0;\n        for(int n:nums){if(!cnt)cand=n;cnt+=(n==cand)?1:-1;}\n        return cand;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int majorityElement(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int majorityElement(int[] nums) {\n        int cnt=0,cand=0;\n        for(int n:nums){if(cnt==0)cand=n;cnt+=(n==cand)?1:-1;}\n        return cand;\n    }\n}"},
         "javascript": {"starter": "var majorityElement = function(nums) {\n};", "solution": "var majorityElement = function(nums) {\n    let cnt=0,cand=0;\n    for(const n of nums){if(!cnt)cand=n;cnt+=(n===cand)?1:-1;}\n    return cand;\n};"},
         "c": {"starter": "int majorityElement(int* nums, int n) { return 0; }", "solution": "int majorityElement(int* nums, int n) {\n    int cnt=0,cand=0;\n    for(int i=0;i<n;i++){if(!cnt)cand=nums[i];cnt+=(nums[i]==cand)?1:-1;}\n    return cand;\n}"},
     }},
]
