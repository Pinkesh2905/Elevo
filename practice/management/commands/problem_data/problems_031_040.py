"""Problems 31-40."""
PROBLEMS = [
    {"number": 70, "title": "Climbing Stairs", "difficulty": "easy", "topics": ["Math", "Dynamic Programming"], "companies": ["Amazon", "Apple", "Google"],
     "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
     "constraints": "1 <= n <= 45", "example_input": "n = 2", "example_output": "2", "example_explanation": "1+1 or 2.",
     "hints": "This is the Fibonacci sequence.\nUse DP: dp[i] = dp[i-1] + dp[i-2].", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "n = 2", "output": "2", "is_sample": True, "explanation": "1+1 or 2"},
                    {"input": "n = 3", "output": "3", "is_sample": True, "explanation": "1+1+1, 1+2, 2+1"},
                    {"input": "n = 5", "output": "8", "is_sample": False, "explanation": "8 ways"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass", "solution": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int climbStairs(int n) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int climbStairs(int n) {\n        int a=1,b=1;\n        for(int i=1;i<n;i++){int t=b;b+=a;a=t;}\n        return b;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int climbStairs(int n) { return 0; }\n}", "solution": "class Solution {\n    public int climbStairs(int n) {\n        int a=1,b=1;\n        for(int i=1;i<n;i++){int t=b;b+=a;a=t;}\n        return b;\n    }\n}"},
         "javascript": {"starter": "var climbStairs = function(n) {\n};", "solution": "var climbStairs = function(n) {\n    let a=1,b=1;\n    for(let i=1;i<n;i++){let t=b;b+=a;a=t;}\n    return b;\n};"},
         "c": {"starter": "int climbStairs(int n) { return 0; }", "solution": "int climbStairs(int n) {\n    int a=1,b=1;\n    for(int i=1;i<n;i++){int t=b;b+=a;a=t;}\n    return b;\n}"},
     }},
    {"number": 73, "title": "Set Matrix Zeroes", "difficulty": "medium", "topics": ["Arrays", "Hash Table", "Matrix"], "companies": ["Microsoft", "Amazon", "Meta"],
     "description": "Given an `m x n` integer matrix, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.",
     "constraints": "m == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-2^31 <= matrix[i][j] <= 2^31 - 1", "example_input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]", "example_output": "[[1,0,1],[0,0,0],[1,0,1]]",
     "example_explanation": "Row 1 and column 1 are set to 0.", "hints": "Use first row/column as markers.\nProcess in reverse to avoid overwriting markers.", "time_complexity": "O(m*n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]", "output": "[[1,0,1],[0,0,0],[1,0,1]]", "is_sample": True, "explanation": "One zero at (1,1)"},
                    {"input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]", "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]", "is_sample": True, "explanation": "Two zeros"},
                    {"input": "matrix = [[1]]", "output": "[[1]]", "is_sample": False, "explanation": "No zeros"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def setZeroes(self, matrix: list[list[int]]) -> None:\n        pass", "solution": "class Solution:\n    def setZeroes(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        first_row = any(matrix[0][j] == 0 for j in range(n))\n        first_col = any(matrix[i][0] == 0 for i in range(m))\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if first_row:\n            for j in range(n): matrix[0][j] = 0\n        if first_col:\n            for i in range(m): matrix[i][0] = 0"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {}\n};", "solution": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& m) {\n        int R=m.size(),C=m[0].size(); bool fr=false,fc=false;\n        for(int j=0;j<C;j++) if(m[0][j]==0) fr=true;\n        for(int i=0;i<R;i++) if(m[i][0]==0) fc=true;\n        for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][j]==0) m[i][0]=m[0][j]=0;\n        for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0;\n        if(fr) for(int j=0;j<C;j++) m[0][j]=0;\n        if(fc) for(int i=0;i<R;i++) m[i][0]=0;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void setZeroes(int[][] matrix) {}\n}", "solution": "class Solution {\n    public void setZeroes(int[][] m) {\n        int R=m.length,C=m[0].length; boolean fr=false,fc=false;\n        for(int j=0;j<C;j++) if(m[0][j]==0) fr=true;\n        for(int i=0;i<R;i++) if(m[i][0]==0) fc=true;\n        for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][j]==0) {m[i][0]=0;m[0][j]=0;}\n        for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0;\n        if(fr) for(int j=0;j<C;j++) m[0][j]=0;\n        if(fc) for(int i=0;i<R;i++) m[i][0]=0;\n    }\n}"},
         "javascript": {"starter": "var setZeroes = function(matrix) {\n};", "solution": "var setZeroes = function(m) {\n    const R=m.length,C=m[0].length; let fr=false,fc=false;\n    for(let j=0;j<C;j++) if(m[0][j]===0) fr=true;\n    for(let i=0;i<R;i++) if(m[i][0]===0) fc=true;\n    for(let i=1;i<R;i++) for(let j=1;j<C;j++) if(m[i][j]===0) {m[i][0]=0;m[0][j]=0;}\n    for(let i=1;i<R;i++) for(let j=1;j<C;j++) if(m[i][0]===0||m[0][j]===0) m[i][j]=0;\n    if(fr) for(let j=0;j<C;j++) m[0][j]=0;\n    if(fc) for(let i=0;i<R;i++) m[i][0]=0;\n};"},
         "c": {"starter": "void setZeroes(int** m, int R, int* colSizes) {}", "solution": "void setZeroes(int** m, int R, int* cs) {\n    int C=cs[0]; int fr=0,fc=0;\n    for(int j=0;j<C;j++) if(m[0][j]==0) fr=1;\n    for(int i=0;i<R;i++) if(m[i][0]==0) fc=1;\n    for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][j]==0){m[i][0]=0;m[0][j]=0;}\n    for(int i=1;i<R;i++) for(int j=1;j<C;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0;\n    if(fr) for(int j=0;j<C;j++) m[0][j]=0;\n    if(fc) for(int i=0;i<R;i++) m[i][0]=0;\n}"},
     }},
    {"number": 75, "title": "Sort Colors", "difficulty": "medium", "topics": ["Arrays", "Two Pointers", "Sorting"], "companies": ["Amazon", "Microsoft", "Oracle"],
     "description": "Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.",
     "constraints": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.", "example_input": "nums = [2,0,2,1,1,0]", "example_output": "[0,0,1,1,2,2]",
     "example_explanation": "Sorted by color.", "hints": "Use Dutch National Flag algorithm.\nThree pointers: low, mid, high.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [2,0,2,1,1,0]", "output": "[0,0,1,1,2,2]", "is_sample": True, "explanation": "Sorted"},
                    {"input": "nums = [2,0,1]", "output": "[0,1,2]", "is_sample": True, "explanation": "All three colors"},
                    {"input": "nums = [0]", "output": "[0]", "is_sample": False, "explanation": "Single element"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def sortColors(self, nums: list[int]) -> None:\n        pass", "solution": "class Solution:\n    def sortColors(self, nums):\n        lo, mid, hi = 0, 0, len(nums) - 1\n        while mid <= hi:\n            if nums[mid] == 0:\n                nums[lo], nums[mid] = nums[mid], nums[lo]\n                lo += 1; mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[hi] = nums[hi], nums[mid]\n                hi -= 1"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {}\n};", "solution": "class Solution {\npublic:\n    void sortColors(vector<int>& n) {\n        int lo=0,mid=0,hi=n.size()-1;\n        while(mid<=hi){\n            if(n[mid]==0) swap(n[lo++],n[mid++]);\n            else if(n[mid]==1) mid++;\n            else swap(n[mid],n[hi--]);\n        }\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void sortColors(int[] nums) {}\n}", "solution": "class Solution {\n    public void sortColors(int[] n) {\n        int lo=0,mid=0,hi=n.length-1;\n        while(mid<=hi){\n            if(n[mid]==0){int t=n[lo];n[lo]=n[mid];n[mid]=t;lo++;mid++;}\n            else if(n[mid]==1) mid++;\n            else{int t=n[mid];n[mid]=n[hi];n[hi]=t;hi--;}\n        }\n    }\n}"},
         "javascript": {"starter": "var sortColors = function(nums) {\n};", "solution": "var sortColors = function(n) {\n    let lo=0,mid=0,hi=n.length-1;\n    while(mid<=hi){\n        if(n[mid]===0){[n[lo],n[mid]]=[n[mid],n[lo]];lo++;mid++;}\n        else if(n[mid]===1) mid++;\n        else{[n[mid],n[hi]]=[n[hi],n[mid]];hi--;}\n    }\n};"},
         "c": {"starter": "void sortColors(int* nums, int n) {}", "solution": "void sortColors(int* a, int n) {\n    int lo=0,mid=0,hi=n-1;\n    while(mid<=hi){\n        if(a[mid]==0){int t=a[lo];a[lo]=a[mid];a[mid]=t;lo++;mid++;}\n        else if(a[mid]==1) mid++;\n        else{int t=a[mid];a[mid]=a[hi];a[hi]=t;hi--;}\n    }\n}"},
     }},
    {"number": 76, "title": "Minimum Window Substring", "difficulty": "hard", "topics": ["Strings", "Hash Table", "Sliding Window"], "companies": ["Meta", "Google", "Amazon"],
     "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.",
     "constraints": "m == s.length\nn == t.length\n1 <= m, n <= 10^5\ns and t consist of uppercase and lowercase English letters.", "example_input": 's = "ADOBECODEBANC", t = "ABC"', "example_output": '"BANC"',
     "example_explanation": "BANC is the minimum window containing A, B, C.", "hints": "Use sliding window with two pointers.\nExpand right to satisfy, contract left to minimize.", "time_complexity": "O(m+n)", "space_complexity": "O(m+n)",
     "test_cases": [{"input": 's = "ADOBECODEBANC"\nt = "ABC"', "output": '"BANC"', "is_sample": True, "explanation": "Minimum window"},
                    {"input": 's = "a"\nt = "a"', "output": '"a"', "is_sample": True, "explanation": "Exact match"},
                    {"input": 's = "a"\nt = "aa"', "output": '""', "is_sample": False, "explanation": "Not enough chars"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        pass", "solution": "from collections import Counter\nclass Solution:\n    def minWindow(self, s, t):\n        need = Counter(t)\n        missing = len(t)\n        l = start = 0\n        end = float('inf')\n        for r, c in enumerate(s):\n            if need[c] > 0: missing -= 1\n            need[c] -= 1\n            while missing == 0:\n                if r - l < end - start:\n                    start, end = l, r\n                need[s[l]] += 1\n                if need[s[l]] > 0: missing += 1\n                l += 1\n        return '' if end == float('inf') else s[start:end+1]"},
         "cpp17": {"starter": "class Solution {\npublic:\n    string minWindow(string s, string t) { return \"\"; }\n};", "solution": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        int need[128]={}; for(char c:t) need[c]++;\n        int missing=t.size(),l=0,start=0,len=INT_MAX;\n        for(int r=0;r<s.size();r++){\n            if(need[s[r]]-->0) missing--;\n            while(!missing){\n                if(r-l+1<len){start=l;len=r-l+1;}\n                if(++need[s[l++]]>0) missing++;\n            }\n        }\n        return len==INT_MAX?\"\":s.substr(start,len);\n    }\n};"},
         "java": {"starter": "class Solution {\n    public String minWindow(String s, String t) { return \"\"; }\n}", "solution": "class Solution {\n    public String minWindow(String s, String t) {\n        int[] need = new int[128]; for(char c:t.toCharArray()) need[c]++;\n        int missing=t.length(),l=0,start=0,len=Integer.MAX_VALUE;\n        for(int r=0;r<s.length();r++){\n            if(need[s.charAt(r)]-->0) missing--;\n            while(missing==0){\n                if(r-l+1<len){start=l;len=r-l+1;}\n                if(++need[s.charAt(l++)]>0) missing++;\n            }\n        }\n        return len==Integer.MAX_VALUE?\"\":s.substring(start,start+len);\n    }\n}"},
         "javascript": {"starter": "var minWindow = function(s, t) {\n};", "solution": "var minWindow = function(s, t) {\n    const need = {}; for(const c of t) need[c]=(need[c]||0)+1;\n    let missing=t.length,l=0,start=0,len=Infinity;\n    for(let r=0;r<s.length;r++){\n        if((need[s[r]]=(need[s[r]]||0)-1)>=0) missing--;\n        while(!missing){\n            if(r-l+1<len){start=l;len=r-l+1;}\n            if(++need[s[l++]]>0) missing++;\n        }\n    }\n    return len===Infinity?'':s.substr(start,len);\n};"},
         "c": {"starter": "char* minWindow(char* s, char* t) { return \"\"; }", "solution": "char* minWindow(char* s, char* t) {\n    int need[128]={0}; int tl=strlen(t),sl=strlen(s);\n    for(int i=0;i<tl;i++) need[(int)t[i]]++;\n    int miss=tl,l=0,start=0,len=sl+1;\n    for(int r=0;r<sl;r++){\n        if(need[(int)s[r]]-->0) miss--;\n        while(!miss){\n            if(r-l+1<len){start=l;len=r-l+1;}\n            if(++need[(int)s[l++]]>0) miss++;\n        }\n    }\n    if(len>sl) return \"\";\n    char* res=malloc(len+1); strncpy(res,s+start,len); res[len]=0; return res;\n}"},
     }},
    {"number": 78, "title": "Subsets", "difficulty": "medium", "topics": ["Arrays", "Backtracking", "Bit Manipulation"], "companies": ["Amazon", "Meta", "Bloomberg"],
     "description": "Given an integer array `nums` of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
     "constraints": "1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll the numbers of nums are unique.", "example_input": "nums = [1,2,3]", "example_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
     "example_explanation": "All 8 subsets.", "hints": "Use backtracking or bit manipulation.\nFor each element, choose to include or exclude.", "time_complexity": "O(n*2^n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [1,2,3]", "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]", "is_sample": True, "explanation": "8 subsets"},
                    {"input": "nums = [0]", "output": "[[],[0]]", "is_sample": True, "explanation": "2 subsets"},
                    {"input": "nums = [1,2]", "output": "[[],[1],[2],[1,2]]", "is_sample": False, "explanation": "4 subsets"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        pass", "solution": "class Solution:\n    def subsets(self, nums):\n        res = []\n        def bt(start, cur):\n            res.append(cur[:])\n            for i in range(start, len(nums)):\n                cur.append(nums[i])\n                bt(i + 1, cur)\n                cur.pop()\n        bt(0, [])\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> res; vector<int> cur;\n        function<void(int)> bt = [&](int s) {\n            res.push_back(cur);\n            for(int i=s;i<nums.size();i++){cur.push_back(nums[i]);bt(i+1);cur.pop_back();}\n        };\n        bt(0); return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) { return new ArrayList<>(); }\n}", "solution": "class Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        bt(nums, 0, new ArrayList<>()); return res;\n    }\n    void bt(int[] nums, int s, List<Integer> cur) {\n        res.add(new ArrayList<>(cur));\n        for(int i=s;i<nums.length;i++){cur.add(nums[i]);bt(nums,i+1,cur);cur.remove(cur.size()-1);}\n    }\n}"},
         "javascript": {"starter": "var subsets = function(nums) {\n};", "solution": "var subsets = function(nums) {\n    const res = [];\n    const bt = (s, cur) => {\n        res.push([...cur]);\n        for(let i=s;i<nums.length;i++){cur.push(nums[i]);bt(i+1,cur);cur.pop();}\n    };\n    bt(0, []); return res;\n};"},
         "c": {"starter": "int** subsets(int* nums, int n, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0; return NULL;\n}", "solution": "int** res; int rSz; int* colSz;\nvoid bt(int* nums, int n, int s, int* cur, int cLen) {\n    res[rSz]=malloc(cLen*4); memcpy(res[rSz],cur,cLen*4); colSz[rSz++]=cLen;\n    for(int i=s;i<n;i++){cur[cLen]=nums[i];bt(nums,n,i+1,cur,cLen+1);}\n}\nint** subsets(int* nums, int n, int* returnSize, int** returnColumnSizes) {\n    int total=1<<n; res=malloc(total*sizeof(int*)); colSz=malloc(total*4); rSz=0;\n    int cur[10]; bt(nums,n,0,cur,0);\n    *returnSize=rSz; *returnColumnSizes=colSz; return res;\n}"},
     }},
    {"number": 88, "title": "Merge Sorted Array", "difficulty": "easy", "topics": ["Arrays", "Two Pointers", "Sorting"], "companies": ["Meta", "Amazon", "Microsoft"],
     "description": "You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\nMerge `nums2` into `nums1` as one sorted array.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array `nums1`.",
     "constraints": "nums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n-10^9 <= nums1[i], nums2[j] <= 10^9", "example_input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3", "example_output": "[1,2,2,3,5,6]",
     "example_explanation": "Merged result.", "hints": "Merge from the end to avoid overwriting.\nUse three pointers: end of nums1 data, end of nums2, end of nums1 array.", "time_complexity": "O(m+n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums1 = [1,2,3,0,0,0]\nm = 3\nnums2 = [2,5,6]\nn = 3", "output": "[1,2,2,3,5,6]", "is_sample": True, "explanation": "Merged"},
                    {"input": "nums1 = [1]\nm = 1\nnums2 = []\nn = 0", "output": "[1]", "is_sample": True, "explanation": "Nothing to merge"},
                    {"input": "nums1 = [0]\nm = 0\nnums2 = [1]\nn = 1", "output": "[1]", "is_sample": False, "explanation": "nums1 empty"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n        pass", "solution": "class Solution:\n    def merge(self, nums1, m, nums2, n):\n        i, j, k = m - 1, n - 1, m + n - 1\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]; i -= 1\n            else:\n                nums1[k] = nums2[j]; j -= 1\n            k -= 1"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void merge(vector<int>& n1, int m, vector<int>& n2, int n) {}\n};", "solution": "class Solution {\npublic:\n    void merge(vector<int>& n1, int m, vector<int>& n2, int n) {\n        int i=m-1,j=n-1,k=m+n-1;\n        while(j>=0){\n            if(i>=0&&n1[i]>n2[j]) n1[k--]=n1[i--];\n            else n1[k--]=n2[j--];\n        }\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void merge(int[] n1, int m, int[] n2, int n) {}\n}", "solution": "class Solution {\n    public void merge(int[] n1, int m, int[] n2, int n) {\n        int i=m-1,j=n-1,k=m+n-1;\n        while(j>=0){\n            if(i>=0&&n1[i]>n2[j]) n1[k--]=n1[i--];\n            else n1[k--]=n2[j--];\n        }\n    }\n}"},
         "javascript": {"starter": "var merge = function(nums1, m, nums2, n) {\n};", "solution": "var merge = function(n1, m, n2, n) {\n    let i=m-1,j=n-1,k=m+n-1;\n    while(j>=0){\n        if(i>=0&&n1[i]>n2[j]) n1[k--]=n1[i--];\n        else n1[k--]=n2[j--];\n    }\n};"},
         "c": {"starter": "void merge(int* n1, int n1Size, int m, int* n2, int n2Size, int n) {}", "solution": "void merge(int* n1, int n1s, int m, int* n2, int n2s, int n) {\n    int i=m-1,j=n-1,k=m+n-1;\n    while(j>=0){\n        if(i>=0&&n1[i]>n2[j]) n1[k--]=n1[i--];\n        else n1[k--]=n2[j--];\n    }\n}"},
     }},
    {"number": 94, "title": "Binary Tree Inorder Traversal", "difficulty": "easy", "topics": ["Trees", "Stack", "Recursion"], "companies": ["Amazon", "Microsoft", "Google"],
     "description": "Given the `root` of a binary tree, return the inorder traversal of its nodes' values.",
     "constraints": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100", "example_input": "root = [1,null,2,3]", "example_output": "[1,3,2]",
     "example_explanation": "Inorder: left, root, right.", "hints": "Use recursion or an iterative approach with a stack.\nGo left as far as possible, visit, then go right.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,null,2,3]", "output": "[1,3,2]", "is_sample": True, "explanation": "Inorder traversal"},
                    {"input": "root = []", "output": "[]", "is_sample": True, "explanation": "Empty tree"},
                    {"input": "root = [1]", "output": "[1]", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val; self.left = left; self.right = right\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> list[int]:\n        pass", "solution": "class Solution:\n    def inorderTraversal(self, root):\n        res = []\n        def dfs(node):\n            if not node: return\n            dfs(node.left)\n            res.append(node.val)\n            dfs(node.right)\n        dfs(root)\n        return res"},
         "cpp17": {"starter": "struct TreeNode { int val; TreeNode *left, *right; TreeNode(int x):val(x),left(nullptr),right(nullptr){} };\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> res; stack<TreeNode*> st;\n        while(root||!st.empty()){\n            while(root){st.push(root);root=root->left;}\n            root=st.top();st.pop();\n            res.push_back(root->val);\n            root=root->right;\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) { return new ArrayList<>(); }\n}", "solution": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> st = new Stack<>();\n        while(root!=null||!st.isEmpty()){\n            while(root!=null){st.push(root);root=root.left;}\n            root=st.pop(); res.add(root.val); root=root.right;\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var inorderTraversal = function(root) {\n};", "solution": "var inorderTraversal = function(root) {\n    const res = [], st = [];\n    while(root||st.length){\n        while(root){st.push(root);root=root.left;}\n        root=st.pop(); res.push(root.val); root=root.right;\n    }\n    return res;\n};"},
         "c": {"starter": "int* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    *returnSize = 0; return NULL;\n}", "solution": "void dfs(struct TreeNode* n, int* res, int* sz) {\n    if(!n) return;\n    dfs(n->left,res,sz); res[(*sz)++]=n->val; dfs(n->right,res,sz);\n}\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    int* res = malloc(100*sizeof(int)); *returnSize = 0;\n    dfs(root, res, returnSize); return res;\n}"},
     }},
    {"number": 98, "title": "Validate Binary Search Tree", "difficulty": "medium", "topics": ["Trees", "Binary Search", "Recursion"], "companies": ["Amazon", "Meta", "Bloomberg"],
     "description": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.",
     "constraints": "The number of nodes in the tree is in the range [1, 10^4].\n-2^31 <= Node.val <= 2^31 - 1", "example_input": "root = [2,1,3]", "example_output": "true",
     "example_explanation": "Left < root < right.", "hints": "Pass down valid range (min, max) to each node.\nInorder traversal of BST should be sorted.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [2,1,3]", "output": "true", "is_sample": True, "explanation": "Valid BST"},
                    {"input": "root = [5,1,4,null,null,3,6]", "output": "false", "is_sample": True, "explanation": "4 < 5 but in right subtree"},
                    {"input": "root = [1]", "output": "true", "is_sample": False, "explanation": "Single node is valid"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        pass", "solution": "class Solution:\n    def isValidBST(self, root):\n        def valid(node, lo, hi):\n            if not node: return True\n            if node.val <= lo or node.val >= hi: return False\n            return valid(node.left, lo, node.val) and valid(node.right, node.val, hi)\n        return valid(root, float('-inf'), float('inf'))"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isValidBST(TreeNode* root) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return valid(root, LONG_MIN, LONG_MAX);\n    }\n    bool valid(TreeNode* n, long lo, long hi) {\n        if(!n) return true;\n        if(n->val<=lo||n->val>=hi) return false;\n        return valid(n->left,lo,n->val)&&valid(n->right,n->val,hi);\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isValidBST(TreeNode root) { return false; }\n}", "solution": "class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    boolean valid(TreeNode n, long lo, long hi) {\n        if(n==null) return true;\n        if(n.val<=lo||n.val>=hi) return false;\n        return valid(n.left,lo,n.val)&&valid(n.right,n.val,hi);\n    }\n}"},
         "javascript": {"starter": "var isValidBST = function(root) {\n};", "solution": "var isValidBST = function(root) {\n    const valid = (n, lo, hi) => {\n        if(!n) return true;\n        if(n.val<=lo||n.val>=hi) return false;\n        return valid(n.left,lo,n.val)&&valid(n.right,n.val,hi);\n    };\n    return valid(root, -Infinity, Infinity);\n};"},
         "c": {"starter": "#include <stdbool.h>\n#include <limits.h>\nbool isValidBST(struct TreeNode* root) { return false; }", "solution": "bool valid(struct TreeNode* n, long lo, long hi) {\n    if(!n) return true;\n    if(n->val<=lo||n->val>=hi) return false;\n    return valid(n->left,lo,n->val)&&valid(n->right,n->val,hi);\n}\nbool isValidBST(struct TreeNode* root) { return valid(root, LONG_MIN, LONG_MAX); }"},
     }},
    {"number": 100, "title": "Same Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
     "constraints": "The number of nodes in both trees is in the range [0, 100].\n-10^4 <= Node.val <= 10^4", "example_input": "p = [1,2,3], q = [1,2,3]", "example_output": "true",
     "example_explanation": "Both trees are identical.", "hints": "Compare nodes recursively.\nCheck if both are null, one is null, or values differ.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "p = [1,2,3]\nq = [1,2,3]", "output": "true", "is_sample": True, "explanation": "Identical trees"},
                    {"input": "p = [1,2]\nq = [1,null,2]", "output": "false", "is_sample": True, "explanation": "Different structure"},
                    {"input": "p = []\nq = []", "output": "true", "is_sample": False, "explanation": "Both empty"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        pass", "solution": "class Solution:\n    def isSameTree(self, p, q):\n        if not p and not q: return True\n        if not p or not q: return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q) return true;\n        if(!p||!q) return false;\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) { return false; }\n}", "solution": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null) return true;\n        if(p==null||q==null) return false;\n        return p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}"},
         "javascript": {"starter": "var isSameTree = function(p, q) {\n};", "solution": "var isSameTree = function(p, q) {\n    if(!p&&!q) return true;\n    if(!p||!q) return false;\n    return p.val===q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n};"},
         "c": {"starter": "bool isSameTree(struct TreeNode* p, struct TreeNode* q) { return false; }", "solution": "bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\n    if(!p&&!q) return true;\n    if(!p||!q) return false;\n    return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n}"},
     }},
]
