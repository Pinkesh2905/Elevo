"""Problems 81-90."""
PROBLEMS = [
    {"number": 148, "title": "Sort List", "difficulty": "medium", "topics": ["Linked List", "Sorting"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given the `head` of a linked list, return the list after sorting it in ascending order.", "constraints": "The number of nodes in the list is in the range [0, 5 * 10^4].\n-10^5 <= Node.val <= 10^5",
     "example_input": "head = [4,2,1,3]", "example_output": "[1,2,3,4]", "example_explanation": "Sorted list.",
     "hints": "Use merge sort for linked list.\nSplit list using slow/fast pointers.", "time_complexity": "O(n log n)", "space_complexity": "O(log n)",
     "test_cases": [{"input": "head = [4,2,1,3]", "output": "[1,2,3,4]", "is_sample": True, "explanation": "Sorted"},
                    {"input": "head = [-1,5,3,4,0]", "output": "[-1,0,3,4,5]", "is_sample": True, "explanation": "Sorted with negatives"},
                    {"input": "head = []", "output": "[]", "is_sample": False, "explanation": "Empty list"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        pass", "solution": "class Solution:\n    def sortList(self, head):\n        if not head or not head.next: return head\n        slow, fast = head, head.next\n        while fast and fast.next: slow = slow.next; fast = fast.next.next\n        mid = slow.next; slow.next = None\n        l, r = self.sortList(head), self.sortList(mid)\n        dummy = cur = ListNode(0)\n        while l and r:\n            if l.val < r.val: cur.next = l; l = l.next\n            else: cur.next = r; r = r.next\n            cur = cur.next\n        cur.next = l or r\n        return dummy.next"},
         "cpp17": {"starter": "class Solution {\npublic:\n    ListNode* sortList(ListNode* head) { return nullptr; }\n};", "solution": "class Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(!head||!head->next) return head;\n        ListNode *slow=head,*fast=head->next;\n        while(fast&&fast->next){slow=slow->next;fast=fast->next->next;}\n        ListNode* mid=slow->next;slow->next=nullptr;\n        ListNode *l=sortList(head),*r=sortList(mid);\n        ListNode dummy(0); ListNode* cur=&dummy;\n        while(l&&r){if(l->val<r->val){cur->next=l;l=l->next;}else{cur->next=r;r=r->next;}cur=cur->next;}\n        cur->next=l?l:r;\n        return dummy.next;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public ListNode sortList(ListNode head) { return null; }\n}", "solution": "class Solution {\n    public ListNode sortList(ListNode head) {\n        if(head==null||head.next==null) return head;\n        ListNode slow=head,fast=head.next;\n        while(fast!=null&&fast.next!=null){slow=slow.next;fast=fast.next.next;}\n        ListNode mid=slow.next;slow.next=null;\n        ListNode l=sortList(head),r=sortList(mid);\n        ListNode dummy=new ListNode(0),cur=dummy;\n        while(l!=null&&r!=null){if(l.val<r.val){cur.next=l;l=l.next;}else{cur.next=r;r=r.next;}cur=cur.next;}\n        cur.next=l!=null?l:r;\n        return dummy.next;\n    }\n}"},
         "javascript": {"starter": "var sortList = function(head) {\n};", "solution": "var sortList = function(head) {\n    if(!head||!head.next) return head;\n    let slow=head,fast=head.next;\n    while(fast&&fast.next){slow=slow.next;fast=fast.next.next;}\n    let mid=slow.next;slow.next=null;\n    let l=sortList(head),r=sortList(mid);\n    const dummy={val:0,next:null};let cur=dummy;\n    while(l&&r){if(l.val<r.val){cur.next=l;l=l.next;}else{cur.next=r;r=r.next;}cur=cur.next;}\n    cur.next=l||r;\n    return dummy.next;\n};"},
         "c": {"starter": "struct ListNode* sortList(struct ListNode* head) { return NULL; }", "solution": "struct ListNode* merge(struct ListNode* l, struct ListNode* r) {\n    struct ListNode dummy={0,NULL},*cur=&dummy;\n    while(l&&r){if(l->val<r->val){cur->next=l;l=l->next;}else{cur->next=r;r=r->next;}cur=cur->next;}\n    cur->next=l?l:r; return dummy.next;\n}\nstruct ListNode* sortList(struct ListNode* head) {\n    if(!head||!head->next) return head;\n    struct ListNode *slow=head,*fast=head->next;\n    while(fast&&fast->next){slow=slow->next;fast=fast->next->next;}\n    struct ListNode* mid=slow->next;slow->next=NULL;\n    return merge(sortList(head),sortList(mid));\n}"},
     }},
    {"number": 160, "title": "Intersection of Two Linked Lists", "difficulty": "easy", "topics": ["Linked List", "Two Pointers"], "companies": ["Amazon", "Meta", "Bloomberg"],
     "description": "Given the heads of two singly linked-lists `headA` and `headB`, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `null`.", "constraints": "The number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 10^4\n1 <= Node.val <= 10^5",
     "example_input": "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3", "example_output": "Intersected at '8'", "example_explanation": "Lists intersect at node with value 8.",
     "hints": "Two pointers technique.\nWhen one reaches end, redirect to other list's head.", "time_complexity": "O(m+n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "listA = [4,1,8,4,5]\nlistB = [5,6,1,8,4,5]", "output": "8", "is_sample": True, "explanation": "Intersect at 8"},
                    {"input": "listA = [2,6,4]\nlistB = [1,5]", "output": "null", "is_sample": True, "explanation": "No intersection"},
                    {"input": "listA = [1]\nlistB = [1]", "output": "1", "is_sample": False, "explanation": "Same single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pass", "solution": "class Solution:\n    def getIntersectionNode(self, headA, headB):\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a"},
         "cpp17": {"starter": "class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { return nullptr; }\n};", "solution": "class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *a=headA,*b=headB;\n        while(a!=b){a=a?a->next:headB;b=b?b->next:headA;}\n        return a;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) { return null; }\n}", "solution": "class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a=headA,b=headB;\n        while(a!=b){a=a!=null?a.next:headB;b=b!=null?b.next:headA;}\n        return a;\n    }\n}"},
         "javascript": {"starter": "var getIntersectionNode = function(headA, headB) {\n};", "solution": "var getIntersectionNode = function(headA, headB) {\n    let a=headA,b=headB;\n    while(a!==b){a=a?a.next:headB;b=b?b.next:headA;}\n    return a;\n};"},
         "c": {"starter": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { return NULL; }", "solution": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *a=headA,*b=headB;\n    while(a!=b){a=a?a->next:headB;b=b?b->next:headA;}\n    return a;\n}"},
     }},
    {"number": 199, "title": "Binary Tree Right Side View", "difficulty": "medium", "topics": ["Trees", "Graphs"], "companies": ["Meta", "Amazon", "Bloomberg"],
     "description": "Given the `root` of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.", "constraints": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
     "example_input": "root = [1,2,3,null,5,null,4]", "example_output": "[1,3,4]", "example_explanation": "Rightmost nodes at each level.",
     "hints": "Use BFS and take the last node at each level.\nOr DFS visiting right child first.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,3,null,5,null,4]", "output": "[1,3,4]", "is_sample": True, "explanation": "Right side view"},
                    {"input": "root = [1,null,3]", "output": "[1,3]", "is_sample": True, "explanation": "Right child only"},
                    {"input": "root = []", "output": "[]", "is_sample": False, "explanation": "Empty tree"}],
     "templates": {
         "python3": {"starter": "from collections import deque\nclass Solution:\n    def rightSideView(self, root: TreeNode) -> list[int]:\n        pass", "solution": "from collections import deque\nclass Solution:\n    def rightSideView(self, root):\n        if not root: return []\n        res, q = [], deque([root])\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n            res.append(node.val)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        if(!root) return {};\n        vector<int> res; queue<TreeNode*> q; q.push(root);\n        while(!q.empty()){\n            int sz=q.size(); TreeNode* n;\n            for(int i=0;i<sz;i++){n=q.front();q.pop();if(n->left)q.push(n->left);if(n->right)q.push(n->right);}\n            res.push_back(n->val);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) { return new ArrayList<>(); }\n}", "solution": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res=new ArrayList<>(); if(root==null) return res;\n        Queue<TreeNode> q=new LinkedList<>(); q.add(root);\n        while(!q.isEmpty()){\n            int sz=q.size(); TreeNode n=null;\n            for(int i=0;i<sz;i++){n=q.poll();if(n.left!=null)q.add(n.left);if(n.right!=null)q.add(n.right);}\n            res.add(n.val);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var rightSideView = function(root) {\n};", "solution": "var rightSideView = function(root) {\n    if(!root) return [];\n    const res=[]; let q=[root];\n    while(q.length){\n        res.push(q[q.length-1].val);\n        const next=[];\n        for(const n of q){if(n.left)next.push(n.left);if(n.right)next.push(n.right);}\n        q=next;\n    }\n    return res;\n};"},
         "c": {"starter": "int* rightSideView(struct TreeNode* root, int* returnSize) { *returnSize=0; return NULL; }", "solution": "int* rightSideView(struct TreeNode* root, int* returnSize) {\n    *returnSize=0; if(!root) return NULL;\n    int* res=malloc(100*sizeof(int));\n    struct TreeNode* q[200]; int front=0,back=0;\n    q[back++]=root;\n    while(front<back){\n        int sz=back-front; struct TreeNode* n;\n        for(int i=0;i<sz;i++){n=q[front++];if(n->left)q[back++]=n->left;if(n->right)q[back++]=n->right;}\n        res[(*returnSize)++]=n->val;\n    }\n    return res;\n}"},
     }},
    {"number": 230, "title": "Kth Smallest Element in a BST", "difficulty": "medium", "topics": ["Trees", "Binary Search"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given the `root` of a binary search tree, and an integer `k`, return the `k`th smallest value (1-indexed) of all the values of the nodes in the tree.", "constraints": "The number of nodes in the tree is n.\n1 <= k <= n <= 10^4\n0 <= Node.val <= 10^4",
     "example_input": "root = [3,1,4,null,2], k = 1", "example_output": "1", "example_explanation": "1 is the smallest.",
     "hints": "Inorder traversal of BST gives sorted order.\nStop at kth element.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [3,1,4,null,2]\nk = 1", "output": "1", "is_sample": True, "explanation": "Smallest is 1"},
                    {"input": "root = [5,3,6,2,4,null,null,1]\nk = 3", "output": "3", "is_sample": True, "explanation": "3rd smallest"},
                    {"input": "root = [1]\nk = 1", "output": "1", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        pass", "solution": "class Solution:\n    def kthSmallest(self, root, k):\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if k == 0: return root.val\n            root = root.right"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> st;\n        while(true){\n            while(root){st.push(root);root=root->left;}\n            root=st.top();st.pop();\n            if(--k==0) return root->val;\n            root=root->right;\n        }\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int kthSmallest(TreeNode root, int k) { return 0; }\n}", "solution": "class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> st=new Stack<>();\n        while(true){\n            while(root!=null){st.push(root);root=root.left;}\n            root=st.pop();\n            if(--k==0) return root.val;\n            root=root.right;\n        }\n    }\n}"},
         "javascript": {"starter": "var kthSmallest = function(root, k) {\n};", "solution": "var kthSmallest = function(root, k) {\n    const st=[];\n    while(true){\n        while(root){st.push(root);root=root.left;}\n        root=st.pop();\n        if(--k===0) return root.val;\n        root=root.right;\n    }\n};"},
         "c": {"starter": "int kthSmallest(struct TreeNode* root, int k) { return 0; }", "solution": "int kthSmallest(struct TreeNode* root, int k) {\n    struct TreeNode* st[10000]; int top=-1;\n    while(1){\n        while(root){st[++top]=root;root=root->left;}\n        root=st[top--];\n        if(--k==0) return root->val;\n        root=root->right;\n    }\n}"},
     }},
    {"number": 287, "title": "Find the Duplicate Number", "difficulty": "medium", "topics": ["Arrays", "Two Pointers", "Binary Search"], "companies": ["Amazon", "Google", "Microsoft"],
     "description": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only one repeated number in `nums`, return this repeated number.\n\nYou must solve the problem without modifying the array `nums` and uses only constant extra space.", "constraints": "1 <= n <= 10^5\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.",
     "example_input": "nums = [1,3,4,2,2]", "example_output": "2", "example_explanation": "2 is the repeated number.",
     "hints": "Use Floyd's cycle detection.\nTreat the array as a linked list where i -> nums[i].", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [1,3,4,2,2]", "output": "2", "is_sample": True, "explanation": "2 is duplicate"},
                    {"input": "nums = [3,1,3,4,2]", "output": "3", "is_sample": True, "explanation": "3 is duplicate"},
                    {"input": "nums = [1,1]", "output": "1", "is_sample": False, "explanation": "Minimal case"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def findDuplicate(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def findDuplicate(self, nums):\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast: break\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int slow=nums[0],fast=nums[0];\n        do{slow=nums[slow];fast=nums[nums[fast]];}while(slow!=fast);\n        slow=nums[0];\n        while(slow!=fast){slow=nums[slow];fast=nums[fast];}\n        return slow;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int findDuplicate(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow=nums[0],fast=nums[0];\n        do{slow=nums[slow];fast=nums[nums[fast]];}while(slow!=fast);\n        slow=nums[0];\n        while(slow!=fast){slow=nums[slow];fast=nums[fast];}\n        return slow;\n    }\n}"},
         "javascript": {"starter": "var findDuplicate = function(nums) {\n};", "solution": "var findDuplicate = function(nums) {\n    let slow=nums[0],fast=nums[0];\n    do{slow=nums[slow];fast=nums[nums[fast]];}while(slow!==fast);\n    slow=nums[0];\n    while(slow!==fast){slow=nums[slow];fast=nums[fast];}\n    return slow;\n};"},
         "c": {"starter": "int findDuplicate(int* nums, int n) { return 0; }", "solution": "int findDuplicate(int* nums, int n) {\n    int slow=nums[0],fast=nums[0];\n    do{slow=nums[slow];fast=nums[nums[fast]];}while(slow!=fast);\n    slow=nums[0];\n    while(slow!=fast){slow=nums[slow];fast=nums[fast];}\n    return slow;\n}"},
     }},
    {"number": 371, "title": "Sum of Two Integers", "difficulty": "medium", "topics": ["Math", "Bit Manipulation"], "companies": ["Amazon", "Google", "Meta"],
     "description": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.", "constraints": "-1000 <= a, b <= 1000",
     "example_input": "a = 1, b = 2", "example_output": "3", "example_explanation": "1 + 2 = 3.",
     "hints": "XOR gives sum without carry.\nAND then left shift gives carry.\nRepeat until no carry.", "time_complexity": "O(1)", "space_complexity": "O(1)",
     "test_cases": [{"input": "a = 1\nb = 2", "output": "3", "is_sample": True, "explanation": "1+2=3"},
                    {"input": "a = 2\nb = 3", "output": "5", "is_sample": True, "explanation": "2+3=5"},
                    {"input": "a = -1\nb = 1", "output": "0", "is_sample": False, "explanation": "-1+1=0"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        pass", "solution": "class Solution:\n    def getSum(self, a, b):\n        mask = 0xFFFFFFFF\n        while b & mask:\n            carry = (a & b) << 1\n            a = a ^ b\n            b = carry\n        return a & mask if b > mask else a"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int getSum(int a, int b) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int getSum(int a, int b) {\n        while(b){int carry=(a&b)<<1;a=a^b;b=carry;}\n        return a;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int getSum(int a, int b) { return 0; }\n}", "solution": "class Solution {\n    public int getSum(int a, int b) {\n        while(b!=0){int carry=(a&b)<<1;a=a^b;b=carry;}\n        return a;\n    }\n}"},
         "javascript": {"starter": "var getSum = function(a, b) {\n};", "solution": "var getSum = function(a, b) {\n    while(b){const carry=(a&b)<<1;a=a^b;b=carry;}\n    return a;\n};"},
         "c": {"starter": "int getSum(int a, int b) { return 0; }", "solution": "int getSum(int a, int b) {\n    while(b){int carry=(a&b)<<1;a=a^b;b=carry;}\n    return a;\n}"},
     }},
    {"number": 416, "title": "Partition Equal Subset Sum", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given an integer array `nums`, return `true` if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or `false` otherwise.", "constraints": "1 <= nums.length <= 200\n1 <= nums[i] <= 100",
     "example_input": "nums = [1,5,11,5]", "example_output": "true", "example_explanation": "[1,5,5] and [11].",
     "hints": "This is a 0/1 knapsack problem.\nTarget sum is total/2.", "time_complexity": "O(n*sum)", "space_complexity": "O(sum)",
     "test_cases": [{"input": "nums = [1,5,11,5]", "output": "true", "is_sample": True, "explanation": "Can partition"},
                    {"input": "nums = [1,2,3,5]", "output": "false", "is_sample": True, "explanation": "Cannot partition"},
                    {"input": "nums = [1,1]", "output": "true", "is_sample": False, "explanation": "[1] and [1]"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def canPartition(self, nums: list[int]) -> bool:\n        pass", "solution": "class Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2: return False\n        target = total // 2\n        dp = {0}\n        for n in nums:\n            dp = dp | {s + n for s in dp}\n            if target in dp: return True\n        return target in dp"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int total=0; for(int n:nums) total+=n;\n        if(total%2) return false;\n        int t=total/2;\n        vector<bool> dp(t+1,false); dp[0]=true;\n        for(int n:nums) for(int j=t;j>=n;j--) dp[j]=dp[j]||dp[j-n];\n        return dp[t];\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean canPartition(int[] nums) { return false; }\n}", "solution": "class Solution {\n    public boolean canPartition(int[] nums) {\n        int total=0; for(int n:nums) total+=n;\n        if(total%2!=0) return false;\n        int t=total/2;\n        boolean[] dp=new boolean[t+1]; dp[0]=true;\n        for(int n:nums) for(int j=t;j>=n;j--) dp[j]=dp[j]||dp[j-n];\n        return dp[t];\n    }\n}"},
         "javascript": {"starter": "var canPartition = function(nums) {\n};", "solution": "var canPartition = function(nums) {\n    const total=nums.reduce((a,b)=>a+b,0);\n    if(total%2) return false;\n    const t=total/2;\n    const dp=new Array(t+1).fill(false); dp[0]=true;\n    for(const n of nums) for(let j=t;j>=n;j--) dp[j]=dp[j]||dp[j-n];\n    return dp[t];\n};"},
         "c": {"starter": "bool canPartition(int* nums, int n) { return false; }", "solution": "bool canPartition(int* nums, int n) {\n    int total=0; for(int i=0;i<n;i++) total+=nums[i];\n    if(total%2) return false;\n    int t=total/2;\n    bool dp[10001]={0}; dp[0]=true;\n    for(int i=0;i<n;i++) for(int j=t;j>=nums[i];j--) dp[j]=dp[j]||dp[j-nums[i]];\n    return dp[t];\n}"},
     }},
    {"number": 438, "title": "Find All Anagrams in a String", "difficulty": "medium", "topics": ["Strings", "Hash Table", "Sliding Window"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given two strings `s` and `p`, return an array of all the start indices of `p`'s anagrams in `s`. You may return the answer in any order.", "constraints": "1 <= s.length, p.length <= 3 * 10^4\ns and p consist of lowercase English letters.",
     "example_input": 's = "cbaebabacd", p = "abc"', "example_output": "[0,6]", "example_explanation": '"cba" at 0 and "bac" at 6.',
     "hints": "Use sliding window of size p.length.\nCompare character counts.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": 's = "cbaebabacd"\np = "abc"', "output": "[0,6]", "is_sample": True, "explanation": "Anagrams at 0 and 6"},
                    {"input": 's = "abab"\np = "ab"', "output": "[0,1,2]", "is_sample": True, "explanation": "Anagrams at 0,1,2"},
                    {"input": 's = "a"\np = "a"', "output": "[0]", "is_sample": False, "explanation": "Single char match"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        pass", "solution": "from collections import Counter\nclass Solution:\n    def findAnagrams(self, s, p):\n        if len(p) > len(s): return []\n        pc = Counter(p)\n        sc = Counter(s[:len(p)])\n        res = [0] if sc == pc else []\n        for i in range(len(p), len(s)):\n            sc[s[i]] += 1\n            sc[s[i-len(p)]] -= 1\n            if sc[s[i-len(p)]] == 0: del sc[s[i-len(p)]]\n            if sc == pc: res.append(i - len(p) + 1)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        if(s.size()<p.size()) return {};\n        vector<int> res,sc(26,0),pc(26,0);\n        for(int i=0;i<p.size();i++){pc[p[i]-'a']++;sc[s[i]-'a']++;}\n        if(sc==pc) res.push_back(0);\n        for(int i=p.size();i<s.size();i++){\n            sc[s[i]-'a']++;sc[s[i-p.size()]-'a']--;\n            if(sc==pc) res.push_back(i-p.size()+1);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) { return new ArrayList<>(); }\n}", "solution": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res=new ArrayList<>();\n        if(s.length()<p.length()) return res;\n        int[] sc=new int[26],pc=new int[26];\n        for(int i=0;i<p.length();i++){pc[p.charAt(i)-'a']++;sc[s.charAt(i)-'a']++;}\n        if(Arrays.equals(sc,pc)) res.add(0);\n        for(int i=p.length();i<s.length();i++){\n            sc[s.charAt(i)-'a']++;sc[s.charAt(i-p.length())-'a']--;\n            if(Arrays.equals(sc,pc)) res.add(i-p.length()+1);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var findAnagrams = function(s, p) {\n};", "solution": "var findAnagrams = function(s, p) {\n    if(s.length<p.length) return [];\n    const res=[],sc=new Array(26).fill(0),pc=new Array(26).fill(0);\n    for(let i=0;i<p.length;i++){pc[p.charCodeAt(i)-97]++;sc[s.charCodeAt(i)-97]++;}\n    if(sc.join()===pc.join()) res.push(0);\n    for(let i=p.length;i<s.length;i++){\n        sc[s.charCodeAt(i)-97]++;sc[s.charCodeAt(i-p.length)-97]--;\n        if(sc.join()===pc.join()) res.push(i-p.length+1);\n    }\n    return res;\n};"},
         "c": {"starter": "int* findAnagrams(char* s, char* p, int* returnSize) { *returnSize=0; return NULL; }", "solution": "int* findAnagrams(char* s, char* p, int* returnSize) {\n    *returnSize=0; int sl=strlen(s),pl=strlen(p);\n    if(sl<pl) return NULL;\n    int* res=malloc(sl*sizeof(int));\n    int sc[26]={0},pc[26]={0};\n    for(int i=0;i<pl;i++){pc[p[i]-'a']++;sc[s[i]-'a']++;}\n    if(!memcmp(sc,pc,sizeof(sc))) res[(*returnSize)++]=0;\n    for(int i=pl;i<sl;i++){\n        sc[s[i]-'a']++;sc[s[i-pl]-'a']--;\n        if(!memcmp(sc,pc,sizeof(sc))) res[(*returnSize)++]=i-pl+1;\n    }\n    return res;\n}"},
     }},
    {"number": 572, "title": "Minimum Path Sum", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming", "Matrix"], "companies": ["Amazon", "Google", "Goldman Sachs"],
     "description": "Given a `m x n` grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.", "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 200",
     "example_input": "grid = [[1,3,1],[1,5,1],[4,2,1]]", "example_output": "7", "example_explanation": "Path 1→3→1→1→1 = 7.",
     "hints": "DP: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).\nFirst row/column are prefix sums.", "time_complexity": "O(m*n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "grid = [[1,3,1],[1,5,1],[4,2,1]]", "output": "7", "is_sample": True, "explanation": "Min path sum"},
                    {"input": "grid = [[1,2,3],[4,5,6]]", "output": "12", "is_sample": True, "explanation": "1+2+3+6=12"},
                    {"input": "grid = [[1]]", "output": "1", "is_sample": False, "explanation": "Single cell"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def minPathSum(self, grid: list[list[int]]) -> int:\n        pass", "solution": "class Solution:\n    def minPathSum(self, grid):\n        m, n = len(grid), len(grid[0])\n        for i in range(1, m): grid[i][0] += grid[i-1][0]\n        for j in range(1, n): grid[0][j] += grid[0][j-1]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& g) {\n        int m=g.size(),n=g[0].size();\n        for(int i=1;i<m;i++) g[i][0]+=g[i-1][0];\n        for(int j=1;j<n;j++) g[0][j]+=g[0][j-1];\n        for(int i=1;i<m;i++) for(int j=1;j<n;j++) g[i][j]+=min(g[i-1][j],g[i][j-1]);\n        return g[m-1][n-1];\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int minPathSum(int[][] grid) { return 0; }\n}", "solution": "class Solution {\n    public int minPathSum(int[][] g) {\n        int m=g.length,n=g[0].length;\n        for(int i=1;i<m;i++) g[i][0]+=g[i-1][0];\n        for(int j=1;j<n;j++) g[0][j]+=g[0][j-1];\n        for(int i=1;i<m;i++) for(int j=1;j<n;j++) g[i][j]+=Math.min(g[i-1][j],g[i][j-1]);\n        return g[m-1][n-1];\n    }\n}"},
         "javascript": {"starter": "var minPathSum = function(grid) {\n};", "solution": "var minPathSum = function(g) {\n    const m=g.length,n=g[0].length;\n    for(let i=1;i<m;i++) g[i][0]+=g[i-1][0];\n    for(let j=1;j<n;j++) g[0][j]+=g[0][j-1];\n    for(let i=1;i<m;i++) for(let j=1;j<n;j++) g[i][j]+=Math.min(g[i-1][j],g[i][j-1]);\n    return g[m-1][n-1];\n};"},
         "c": {"starter": "int minPathSum(int** grid, int m, int* colSizes) { return 0; }", "solution": "int minPathSum(int** g, int m, int* cs) {\n    int n=cs[0];\n    for(int i=1;i<m;i++) g[i][0]+=g[i-1][0];\n    for(int j=1;j<n;j++) g[0][j]+=g[0][j-1];\n    for(int i=1;i<m;i++) for(int j=1;j<n;j++) g[i][j]+=(g[i-1][j]<g[i][j-1]?g[i-1][j]:g[i][j-1]);\n    return g[m-1][n-1];\n}"},
     }},
    {"number": 11, "title": "Container With Most Water", "difficulty": "medium", "topics": ["Arrays", "Two Pointers", "Greedy"], "companies": ["Amazon", "Google", "Meta"],
     "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.", "constraints": "n == height.length\n2 <= n <= 10^5\n0 <= height[i] <= 10^4",
     "example_input": "height = [1,8,6,2,5,4,8,3,7]", "example_output": "49", "example_explanation": "Lines at index 1 and 8 form the container with most water.",
     "hints": "Use two pointers from both ends.\nMove the shorter line inward.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "height = [1,8,6,2,5,4,8,3,7]", "output": "49", "is_sample": True, "explanation": "Max water between lines 1 and 8"},
                    {"input": "height = [1,1]", "output": "1", "is_sample": True, "explanation": "Min case"},
                    {"input": "height = [4,3,2,1,4]", "output": "16", "is_sample": False, "explanation": "Between index 0 and 4"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxArea(self, height: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def maxArea(self, height):\n        l, r = 0, len(height) - 1\n        res = 0\n        while l < r:\n            res = max(res, min(height[l], height[r]) * (r - l))\n            if height[l] < height[r]: l += 1\n            else: r -= 1\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxArea(vector<int>& height) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int maxArea(vector<int>& h) {\n        int l=0,r=h.size()-1,res=0;\n        while(l<r){\n            res=max(res,min(h[l],h[r])*(r-l));\n            if(h[l]<h[r])l++;else r--;\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int maxArea(int[] height) { return 0; }\n}", "solution": "class Solution {\n    public int maxArea(int[] h) {\n        int l=0,r=h.length-1,res=0;\n        while(l<r){\n            res=Math.max(res,Math.min(h[l],h[r])*(r-l));\n            if(h[l]<h[r])l++;else r--;\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var maxArea = function(height) {\n};", "solution": "var maxArea = function(h) {\n    let l=0,r=h.length-1,res=0;\n    while(l<r){\n        res=Math.max(res,Math.min(h[l],h[r])*(r-l));\n        if(h[l]<h[r])l++;else r--;\n    }\n    return res;\n};"},
         "c": {"starter": "int maxArea(int* height, int n) { return 0; }", "solution": "int maxArea(int* h, int n) {\n    int l=0,r=n-1,res=0;\n    while(l<r){\n        int mn=h[l]<h[r]?h[l]:h[r];\n        int area=mn*(r-l);\n        if(area>res) res=area;\n        if(h[l]<h[r])l++;else r--;\n    }\n    return res;\n}"},
     }},
]
