"""Problems 61-70."""
PROBLEMS = [
    {"number": 242, "title": "Valid Anagram", "difficulty": "easy", "topics": ["Strings", "Hash Table", "Sorting"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.", "constraints": "1 <= s.length, t.length <= 5 * 10^4\ns and t consist of lowercase English letters.",
     "example_input": 's = "anagram", t = "nagaram"', "example_output": "true", "example_explanation": "Both contain the same letters.",
     "hints": "Count character frequencies.\nCompare frequency arrays.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": 's = "anagram"\nt = "nagaram"', "output": "true", "is_sample": True, "explanation": "Valid anagram"},
                    {"input": 's = "rat"\nt = "car"', "output": "false", "is_sample": True, "explanation": "Not anagram"},
                    {"input": 's = "a"\nt = "a"', "output": "true", "is_sample": False, "explanation": "Single char"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        pass", "solution": "class Solution:\n    def isAnagram(self, s, t):\n        return sorted(s) == sorted(t)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isAnagram(string s, string t) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.size()!=t.size()) return false;\n        int cnt[26]={};\n        for(int i=0;i<s.size();i++){cnt[s[i]-'a']++;cnt[t[i]-'a']--;}\n        for(int c:cnt) if(c) return false;\n        return true;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isAnagram(String s, String t) { return false; }\n}", "solution": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()) return false;\n        int[] cnt=new int[26];\n        for(int i=0;i<s.length();i++){cnt[s.charAt(i)-'a']++;cnt[t.charAt(i)-'a']--;}\n        for(int c:cnt) if(c!=0) return false;\n        return true;\n    }\n}"},
         "javascript": {"starter": "var isAnagram = function(s, t) {\n};", "solution": "var isAnagram = function(s, t) {\n    return s.split('').sort().join('') === t.split('').sort().join('');\n};"},
         "c": {"starter": "bool isAnagram(char* s, char* t) { return false; }", "solution": "bool isAnagram(char* s, char* t) {\n    int cnt[26]={0};\n    for(;*s;s++) cnt[*s-'a']++;\n    for(;*t;t++) cnt[*t-'a']--;\n    for(int i=0;i<26;i++) if(cnt[i]) return false;\n    return true;\n}"},
     }},
    {"number": 268, "title": "Missing Number", "difficulty": "easy", "topics": ["Arrays", "Math", "Bit Manipulation"], "companies": ["Amazon", "Microsoft", "Apple"],
     "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.", "constraints": "n == nums.length\n1 <= n <= 10^4\n0 <= nums[i] <= n\nAll the numbers of nums are unique.",
     "example_input": "nums = [3,0,1]", "example_output": "2", "example_explanation": "2 is missing from [0,1,3].",
     "hints": "Use XOR or sum formula.\nExpected sum - actual sum = missing number.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [3,0,1]", "output": "2", "is_sample": True, "explanation": "2 is missing"},
                    {"input": "nums = [0,1]", "output": "2", "is_sample": True, "explanation": "2 is missing"},
                    {"input": "nums = [9,6,4,2,3,5,7,0,1]", "output": "8", "is_sample": False, "explanation": "8 is missing"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def missingNumber(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def missingNumber(self, nums):\n        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n=nums.size(), s=n*(n+1)/2;\n        for(int x:nums) s-=x;\n        return s;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int missingNumber(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int missingNumber(int[] nums) {\n        int n=nums.length, s=n*(n+1)/2;\n        for(int x:nums) s-=x;\n        return s;\n    }\n}"},
         "javascript": {"starter": "var missingNumber = function(nums) {\n};", "solution": "var missingNumber = function(nums) {\n    const n=nums.length;\n    return n*(n+1)/2-nums.reduce((a,b)=>a+b,0);\n};"},
         "c": {"starter": "int missingNumber(int* nums, int n) { return 0; }", "solution": "int missingNumber(int* nums, int n) {\n    int s=n*(n+1)/2;\n    for(int i=0;i<n;i++) s-=nums[i];\n    return s;\n}"},
     }},
    {"number": 283, "title": "Move Zeroes", "difficulty": "easy", "topics": ["Arrays", "Two Pointers"], "companies": ["Meta", "Amazon", "Apple"],
     "description": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.", "constraints": "1 <= nums.length <= 10^4\n-2^31 <= nums[i] <= 2^31 - 1",
     "example_input": "nums = [0,1,0,3,12]", "example_output": "[1,3,12,0,0]", "example_explanation": "Non-zeros moved to front maintaining order.",
     "hints": "Use two pointers: one for reading, one for writing.\nWrite non-zero values, then fill rest with zeros.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [0,1,0,3,12]", "output": "[1,3,12,0,0]", "is_sample": True, "explanation": "Zeros moved to end"},
                    {"input": "nums = [0]", "output": "[0]", "is_sample": True, "explanation": "Single zero"},
                    {"input": "nums = [1,2,3]", "output": "[1,2,3]", "is_sample": False, "explanation": "No zeros"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def moveZeroes(self, nums: list[int]) -> None:\n        pass", "solution": "class Solution:\n    def moveZeroes(self, nums):\n        k = 0\n        for n in nums:\n            if n != 0:\n                nums[k] = n\n                k += 1\n        while k < len(nums):\n            nums[k] = 0\n            k += 1"},
         "cpp17": {"starter": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {}\n};", "solution": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int k=0;\n        for(int n:nums) if(n) nums[k++]=n;\n        while(k<nums.size()) nums[k++]=0;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public void moveZeroes(int[] nums) {}\n}", "solution": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int k=0;\n        for(int n:nums) if(n!=0) nums[k++]=n;\n        while(k<nums.length) nums[k++]=0;\n    }\n}"},
         "javascript": {"starter": "var moveZeroes = function(nums) {\n};", "solution": "var moveZeroes = function(nums) {\n    let k=0;\n    for(const n of nums) if(n) nums[k++]=n;\n    while(k<nums.length) nums[k++]=0;\n};"},
         "c": {"starter": "void moveZeroes(int* nums, int n) {}", "solution": "void moveZeroes(int* nums, int n) {\n    int k=0;\n    for(int i=0;i<n;i++) if(nums[i]) nums[k++]=nums[i];\n    while(k<n) nums[k++]=0;\n}"},
     }},
    {"number": 300, "title": "Longest Increasing Subsequence", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming", "Binary Search"], "companies": ["Google", "Amazon", "Microsoft"],
     "description": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.", "constraints": "1 <= nums.length <= 2500\n-10^4 <= nums[i] <= 10^4",
     "example_input": "nums = [10,9,2,5,3,7,101,18]", "example_output": "4", "example_explanation": "The LIS is [2,3,7,101], length 4.",
     "hints": "Use DP: dp[i] = length of LIS ending at index i.\nBinary search optimization: maintain tails array.", "time_complexity": "O(n log n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [10,9,2,5,3,7,101,18]", "output": "4", "is_sample": True, "explanation": "LIS: [2,3,7,101]"},
                    {"input": "nums = [0,1,0,3,2,3]", "output": "4", "is_sample": True, "explanation": "LIS: [0,1,2,3]"},
                    {"input": "nums = [7,7,7,7,7]", "output": "1", "is_sample": False, "explanation": "All same, LIS=1"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def lengthOfLIS(self, nums: list[int]) -> int:\n        pass", "solution": "import bisect\nclass Solution:\n    def lengthOfLIS(self, nums):\n        tails = []\n        for n in nums:\n            pos = bisect.bisect_left(tails, n)\n            if pos == len(tails): tails.append(n)\n            else: tails[pos] = n\n        return len(tails)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> tails;\n        for(int n:nums){\n            auto it=lower_bound(tails.begin(),tails.end(),n);\n            if(it==tails.end()) tails.push_back(n);\n            else *it=n;\n        }\n        return tails.size();\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int lengthOfLIS(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] tails=new int[nums.length]; int sz=0;\n        for(int n:nums){\n            int lo=0,hi=sz;\n            while(lo<hi){int m=(lo+hi)/2;if(tails[m]<n)lo=m+1;else hi=m;}\n            tails[lo]=n;\n            if(lo==sz) sz++;\n        }\n        return sz;\n    }\n}"},
         "javascript": {"starter": "var lengthOfLIS = function(nums) {\n};", "solution": "var lengthOfLIS = function(nums) {\n    const tails=[];\n    for(const n of nums){\n        let lo=0,hi=tails.length;\n        while(lo<hi){const m=(lo+hi)>>1;if(tails[m]<n)lo=m+1;else hi=m;}\n        tails[lo]=n;\n    }\n    return tails.length;\n};"},
         "c": {"starter": "int lengthOfLIS(int* nums, int n) { return 0; }", "solution": "int lengthOfLIS(int* nums, int n) {\n    int tails[2500], sz=0;\n    for(int i=0;i<n;i++){\n        int lo=0,hi=sz;\n        while(lo<hi){int m=(lo+hi)/2;if(tails[m]<nums[i])lo=m+1;else hi=m;}\n        tails[lo]=nums[i];\n        if(lo==sz) sz++;\n    }\n    return sz;\n}"},
     }},
    {"number": 322, "title": "Coin Change", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.", "constraints": "1 <= coins.length <= 12\n1 <= coins[i] <= 2^31 - 1\n0 <= amount <= 10^4",
     "example_input": "coins = [1,5,10], amount = 12", "example_output": "3", "example_explanation": "12 = 10 + 1 + 1.",
     "hints": "Use DP: dp[i] = min coins to make amount i.\ndp[i] = min(dp[i], dp[i - coin] + 1) for each coin.", "time_complexity": "O(n*amount)", "space_complexity": "O(amount)",
     "test_cases": [{"input": "coins = [1,5,10]\namount = 12", "output": "3", "is_sample": True, "explanation": "10+1+1"},
                    {"input": "coins = [2]\namount = 3", "output": "-1", "is_sample": True, "explanation": "Cannot make 3"},
                    {"input": "coins = [1]\namount = 0", "output": "0", "is_sample": False, "explanation": "Amount is 0"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def coinChange(self, coins: list[int], amount: int) -> int:\n        pass", "solution": "class Solution:\n    def coinChange(self, coins, amount):\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for i in range(1, amount + 1):\n            for c in coins:\n                if c <= i: dp[i] = min(dp[i], dp[i - c] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1, amount+1);\n        dp[0]=0;\n        for(int i=1;i<=amount;i++)\n            for(int c:coins) if(c<=i) dp[i]=min(dp[i],dp[i-c]+1);\n        return dp[amount]>amount?-1:dp[amount];\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int coinChange(int[] coins, int amount) { return 0; }\n}", "solution": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp=new int[amount+1]; Arrays.fill(dp,amount+1);\n        dp[0]=0;\n        for(int i=1;i<=amount;i++)\n            for(int c:coins) if(c<=i) dp[i]=Math.min(dp[i],dp[i-c]+1);\n        return dp[amount]>amount?-1:dp[amount];\n    }\n}"},
         "javascript": {"starter": "var coinChange = function(coins, amount) {\n};", "solution": "var coinChange = function(coins, amount) {\n    const dp=new Array(amount+1).fill(amount+1);\n    dp[0]=0;\n    for(let i=1;i<=amount;i++)\n        for(const c of coins) if(c<=i) dp[i]=Math.min(dp[i],dp[i-c]+1);\n    return dp[amount]>amount?-1:dp[amount];\n};"},
         "c": {"starter": "int coinChange(int* coins, int n, int amount) { return 0; }", "solution": "int coinChange(int* coins, int n, int amount) {\n    int* dp=malloc((amount+1)*sizeof(int));\n    for(int i=0;i<=amount;i++) dp[i]=amount+1;\n    dp[0]=0;\n    for(int i=1;i<=amount;i++)\n        for(int j=0;j<n;j++) if(coins[j]<=i && dp[i-coins[j]]+1<dp[i]) dp[i]=dp[i-coins[j]]+1;\n    int res=dp[amount]>amount?-1:dp[amount]; free(dp); return res;\n}"},
     }},
    {"number": 338, "title": "Counting Bits", "difficulty": "easy", "topics": ["Dynamic Programming", "Bit Manipulation"], "companies": ["Amazon", "Google", "Microsoft"],
     "description": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (`0 <= i <= n`), `ans[i]` is the number of `1`'s in the binary representation of `i`.", "constraints": "0 <= n <= 10^5",
     "example_input": "n = 5", "example_output": "[0,1,1,2,1,2]", "example_explanation": "0=0, 1=1, 2=1, 3=2, 4=1, 5=2.",
     "hints": "dp[i] = dp[i >> 1] + (i & 1).\nUse previously computed results.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "n = 5", "output": "[0,1,1,2,1,2]", "is_sample": True, "explanation": "Bit counts for 0-5"},
                    {"input": "n = 2", "output": "[0,1,1]", "is_sample": True, "explanation": "Bit counts for 0-2"},
                    {"input": "n = 0", "output": "[0]", "is_sample": False, "explanation": "Only 0"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def countBits(self, n: int) -> list[int]:\n        pass", "solution": "class Solution:\n    def countBits(self, n):\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> countBits(int n) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1);\n        return dp;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int[] countBits(int n) { return new int[]{}; }\n}", "solution": "class Solution {\n    public int[] countBits(int n) {\n        int[] dp=new int[n+1];\n        for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1);\n        return dp;\n    }\n}"},
         "javascript": {"starter": "var countBits = function(n) {\n};", "solution": "var countBits = function(n) {\n    const dp=new Array(n+1).fill(0);\n    for(let i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1);\n    return dp;\n};"},
         "c": {"starter": "int* countBits(int n, int* returnSize) { *returnSize=n+1; return NULL; }", "solution": "int* countBits(int n, int* returnSize) {\n    *returnSize=n+1;\n    int* dp=calloc(n+1,sizeof(int));\n    for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1);\n    return dp;\n}"},
     }},
    {"number": 347, "title": "Top K Frequent Elements", "difficulty": "medium", "topics": ["Arrays", "Hash Table", "Heap", "Sorting"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.", "constraints": "1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\nk is in the range [1, the number of unique elements in the array].",
     "example_input": "nums = [1,1,1,2,2,3], k = 2", "example_output": "[1,2]", "example_explanation": "1 and 2 are the two most frequent.",
     "hints": "Count frequencies with a hash map.\nUse bucket sort or a heap.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [1,1,1,2,2,3]\nk = 2", "output": "[1,2]", "is_sample": True, "explanation": "Top 2 frequent"},
                    {"input": "nums = [1]\nk = 1", "output": "[1]", "is_sample": True, "explanation": "Only element"},
                    {"input": "nums = [4,1,-1,2,-1,2,3]\nk = 2", "output": "[-1,2]", "is_sample": False, "explanation": "-1 and 2 appear twice"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n        pass", "solution": "from collections import Counter\nclass Solution:\n    def topKFrequent(self, nums, k):\n        return [x for x, _ in Counter(nums).most_common(k)]"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> cnt;\n        for(int n:nums) cnt[n]++;\n        vector<vector<int>> buckets(nums.size()+1);\n        for(auto&[n,c]:cnt) buckets[c].push_back(n);\n        vector<int> res;\n        for(int i=buckets.size()-1;i>=0&&res.size()<k;i--)\n            for(int n:buckets[i]) { res.push_back(n); if(res.size()==k) break; }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) { return new int[]{}; }\n}", "solution": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer,Integer> cnt=new HashMap<>();\n        for(int n:nums) cnt.merge(n,1,Integer::sum);\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        for(var e:cnt.entrySet()){pq.add(new int[]{e.getKey(),e.getValue()});if(pq.size()>k)pq.poll();}\n        int[] res=new int[k]; int i=0;\n        while(!pq.isEmpty()) res[i++]=pq.poll()[0];\n        return res;\n    }\n}"},
         "javascript": {"starter": "var topKFrequent = function(nums, k) {\n};", "solution": "var topKFrequent = function(nums, k) {\n    const cnt=new Map();\n    for(const n of nums) cnt.set(n,(cnt.get(n)||0)+1);\n    return [...cnt.entries()].sort((a,b)=>b[1]-a[1]).slice(0,k).map(x=>x[0]);\n};"},
         "c": {"starter": "int* topKFrequent(int* nums, int n, int k, int* returnSize) { *returnSize=k; return NULL; }", "solution": "// Uses sorting approach\ntypedef struct{int val,cnt;}Pair;\nint pcmp(const void*a,const void*b){return ((Pair*)b)->cnt-((Pair*)a)->cnt;}\nint icmp(const void*a,const void*b){return *(int*)a-*(int*)b;}\nint* topKFrequent(int* nums, int n, int k, int* returnSize) {\n    qsort(nums,n,sizeof(int),icmp);\n    Pair pairs[n]; int pn=0;\n    for(int i=0;i<n;){\n        int j=i;while(j<n&&nums[j]==nums[i])j++;\n        pairs[pn++]=(Pair){nums[i],j-i}; i=j;\n    }\n    qsort(pairs,pn,sizeof(Pair),pcmp);\n    int* res=malloc(k*sizeof(int));\n    for(int i=0;i<k;i++) res[i]=pairs[i].val;\n    *returnSize=k; return res;\n}"},
     }},
    {"number": 394, "title": "Decode String", "difficulty": "medium", "topics": ["Strings", "Stack", "Recursion"], "companies": ["Google", "Amazon", "Bloomberg"],
     "description": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times.", "constraints": "1 <= s.length <= 30\ns consists of lowercase English letters, digits, and square brackets '[]'.\ns is guaranteed to be a valid input.\nAll the integers in s are in the range [1, 300].",
     "example_input": 's = "3[a]2[bc]"', "example_output": '"aaabcbc"', "example_explanation": "3 times 'a' + 2 times 'bc'.",
     "hints": "Use a stack to handle nested brackets.\nPush current string and count when encountering '['.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": 's = "3[a]2[bc]"', "output": '"aaabcbc"', "is_sample": True, "explanation": "Simple decode"},
                    {"input": 's = "3[a2[c]]"', "output": '"accaccacc"', "is_sample": True, "explanation": "Nested brackets"},
                    {"input": 's = "2[abc]3[cd]ef"', "output": '"abcabccdcdcdef"', "is_sample": False, "explanation": "Mixed with plain text"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def decodeString(self, s: str) -> str:\n        pass", "solution": "class Solution:\n    def decodeString(self, s):\n        stack = []\n        cur = ''\n        num = 0\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append((cur, num))\n                cur, num = '', 0\n            elif c == ']':\n                prev, count = stack.pop()\n                cur = prev + cur * count\n            else:\n                cur += c\n        return cur"},
         "cpp17": {"starter": "class Solution {\npublic:\n    string decodeString(string s) { return \"\"; }\n};", "solution": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<pair<string,int>> st;\n        string cur; int num=0;\n        for(char c:s){\n            if(isdigit(c)) num=num*10+(c-'0');\n            else if(c=='['){st.push({cur,num});cur=\"\";num=0;}\n            else if(c==']'){auto [prev,cnt]=st.top();st.pop();string t;for(int i=0;i<cnt;i++)t+=cur;cur=prev+t;}\n            else cur+=c;\n        }\n        return cur;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public String decodeString(String s) { return \"\"; }\n}", "solution": "class Solution {\n    public String decodeString(String s) {\n        Stack<String> strs=new Stack<>(); Stack<Integer> nums=new Stack<>();\n        StringBuilder cur=new StringBuilder(); int num=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c)) num=num*10+(c-'0');\n            else if(c=='['){strs.push(cur.toString());nums.push(num);cur=new StringBuilder();num=0;}\n            else if(c==']'){String t=cur.toString();cur=new StringBuilder(strs.pop());int cnt=nums.pop();for(int i=0;i<cnt;i++)cur.append(t);}\n            else cur.append(c);\n        }\n        return cur.toString();\n    }\n}"},
         "javascript": {"starter": "var decodeString = function(s) {\n};", "solution": "var decodeString = function(s) {\n    const st=[]; let cur='',num=0;\n    for(const c of s){\n        if(c>='0'&&c<='9') num=num*10+parseInt(c);\n        else if(c==='['){st.push([cur,num]);cur='';num=0;}\n        else if(c===']'){const [prev,cnt]=st.pop();cur=prev+cur.repeat(cnt);}\n        else cur+=c;\n    }\n    return cur;\n};"},
         "c": {"starter": "char* decodeString(char* s) { return \"\"; }", "solution": "char* decodeString(char* s) {\n    char* res=calloc(10000,1); int ri=0;\n    // Simplified iterative approach\n    char strs[30][10000]; int nums[30]; int top=-1;\n    char cur[10000]; int ci=0; int num=0;\n    for(int i=0;s[i];i++){\n        if(s[i]>='0'&&s[i]<='9') num=num*10+(s[i]-'0');\n        else if(s[i]=='['){top++;strcpy(strs[top],cur);nums[top]=num;ci=0;cur[0]=0;num=0;}\n        else if(s[i]==']'){char t[10000];strcpy(t,cur);ci=strlen(strs[top]);strcpy(cur,strs[top]);for(int j=0;j<nums[top];j++){strcpy(cur+ci,t);ci+=strlen(t);}cur[ci]=0;top--;}\n        else{cur[ci++]=s[i];cur[ci]=0;}\n    }\n    strcpy(res,cur); return res;\n}"},
     }},
    {"number": 543, "title": "Diameter of Binary Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Meta", "Amazon", "Google"],
     "description": "Given the `root` of a binary tree, return the length of the diameter of the tree.\n\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.\n\nThe length of a path between two nodes is represented by the number of edges between them.", "constraints": "The number of nodes in the tree is in the range [1, 10^4].\n-100 <= Node.val <= 100",
     "example_input": "root = [1,2,3,4,5]", "example_output": "3", "example_explanation": "Longest path: [4,2,1,3] or [5,2,1,3], length 3.",
     "hints": "At each node, diameter through it = left_height + right_height.\nTrack max diameter globally.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [1,2,3,4,5]", "output": "3", "is_sample": True, "explanation": "Path through root"},
                    {"input": "root = [1,2]", "output": "1", "is_sample": True, "explanation": "One edge"},
                    {"input": "root = [1]", "output": "0", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        pass", "solution": "class Solution:\n    def diameterOfBinaryTree(self, root):\n        self.res = 0\n        def depth(node):\n            if not node: return 0\n            l = depth(node.left)\n            r = depth(node.right)\n            self.res = max(self.res, l + r)\n            return 1 + max(l, r)\n        depth(root)\n        return self.res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) { return 0; }\n};", "solution": "class Solution {\n    int res=0;\n    int depth(TreeNode* n){\n        if(!n) return 0;\n        int l=depth(n->left),r=depth(n->right);\n        res=max(res,l+r);\n        return 1+max(l,r);\n    }\npublic:\n    int diameterOfBinaryTree(TreeNode* root){res=0;depth(root);return res;}\n};"},
         "java": {"starter": "class Solution {\n    public int diameterOfBinaryTree(TreeNode root) { return 0; }\n}", "solution": "class Solution {\n    int res=0;\n    public int diameterOfBinaryTree(TreeNode root){depth(root);return res;}\n    int depth(TreeNode n){\n        if(n==null) return 0;\n        int l=depth(n.left),r=depth(n.right);\n        res=Math.max(res,l+r);\n        return 1+Math.max(l,r);\n    }\n}"},
         "javascript": {"starter": "var diameterOfBinaryTree = function(root) {\n};", "solution": "var diameterOfBinaryTree = function(root) {\n    let res=0;\n    const depth = n => {\n        if(!n) return 0;\n        const l=depth(n.left),r=depth(n.right);\n        res=Math.max(res,l+r);\n        return 1+Math.max(l,r);\n    };\n    depth(root); return res;\n};"},
         "c": {"starter": "int diameterOfBinaryTree(struct TreeNode* root) { return 0; }", "solution": "int res;\nint depth(struct TreeNode* n){\n    if(!n) return 0;\n    int l=depth(n->left),r=depth(n->right);\n    if(l+r>res) res=l+r;\n    return 1+(l>r?l:r);\n}\nint diameterOfBinaryTree(struct TreeNode* root){res=0;depth(root);return res;}"},
     }},
    {"number": 560, "title": "Subarray Sum Equals K", "difficulty": "medium", "topics": ["Arrays", "Hash Table"], "companies": ["Meta", "Amazon", "Google"],
     "description": "Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals to `k`.", "constraints": "1 <= nums.length <= 2 * 10^4\n-1000 <= nums[i] <= 1000\n-10^7 <= k <= 10^7",
     "example_input": "nums = [1,1,1], k = 2", "example_output": "2", "example_explanation": "[1,1] at index 0-1 and 1-2.",
     "hints": "Use prefix sum + hash map.\nIf prefix[j] - prefix[i] = k, then subarray (i,j] sums to k.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "nums = [1,1,1]\nk = 2", "output": "2", "is_sample": True, "explanation": "Two subarrays sum to 2"},
                    {"input": "nums = [1,2,3]\nk = 3", "output": "2", "is_sample": True, "explanation": "[1,2] and [3]"},
                    {"input": "nums = [1]\nk = 0", "output": "0", "is_sample": False, "explanation": "No subarray sums to 0"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def subarraySum(self, nums: list[int], k: int) -> int:\n        pass", "solution": "from collections import defaultdict\nclass Solution:\n    def subarraySum(self, nums, k):\n        count = defaultdict(int)\n        count[0] = 1\n        prefix = res = 0\n        for n in nums:\n            prefix += n\n            res += count[prefix - k]\n            count[prefix] += 1\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int,int> cnt; cnt[0]=1;\n        int prefix=0,res=0;\n        for(int n:nums){prefix+=n;res+=cnt[prefix-k];cnt[prefix]++;}\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int subarraySum(int[] nums, int k) { return 0; }\n}", "solution": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer,Integer> cnt=new HashMap<>(); cnt.put(0,1);\n        int prefix=0,res=0;\n        for(int n:nums){prefix+=n;res+=cnt.getOrDefault(prefix-k,0);cnt.merge(prefix,1,Integer::sum);}\n        return res;\n    }\n}"},
         "javascript": {"starter": "var subarraySum = function(nums, k) {\n};", "solution": "var subarraySum = function(nums, k) {\n    const cnt=new Map(); cnt.set(0,1);\n    let prefix=0,res=0;\n    for(const n of nums){prefix+=n;res+=(cnt.get(prefix-k)||0);cnt.set(prefix,(cnt.get(prefix)||0)+1);}\n    return res;\n};"},
         "c": {"starter": "int subarraySum(int* nums, int n, int k) { return 0; }", "solution": "// Brute force O(n^2) for C\nint subarraySum(int* nums, int n, int k) {\n    int res=0;\n    for(int i=0;i<n;i++){int s=0;for(int j=i;j<n;j++){s+=nums[j];if(s==k)res++;}}\n    return res;\n}"},
     }},
]
