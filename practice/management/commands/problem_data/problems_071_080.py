"""Problems 71-80."""
PROBLEMS = [
    {"number": 572, "title": "Subtree of Another Tree", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Amazon", "Meta", "Google"],
     "description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.", "constraints": "The number of nodes in the root tree is in the range [1, 2000].\nThe number of nodes in the subRoot tree is in the range [1, 1000].\n-10^4 <= root.val <= 10^4\n-10^4 <= subRoot.val <= 10^4",
     "example_input": "root = [3,4,5,1,2], subRoot = [4,1,2]", "example_output": "true", "example_explanation": "The subtree rooted at node 4 matches.",
     "hints": "Check if trees are same at each node.\nRecursively check left and right subtrees.", "time_complexity": "O(m*n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [3,4,5,1,2]\nsubRoot = [4,1,2]", "output": "true", "is_sample": True, "explanation": "Subtree found"},
                    {"input": "root = [3,4,5,1,2,null,null,null,null,0]\nsubRoot = [4,1,2]", "output": "false", "is_sample": True, "explanation": "Not exact match"},
                    {"input": "root = [1]\nsubRoot = [1]", "output": "true", "is_sample": False, "explanation": "Single node match"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:\n        pass", "solution": "class Solution:\n    def isSubtree(self, root, subRoot):\n        if not root: return False\n        if self.same(root, subRoot): return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n    def same(self, a, b):\n        if not a and not b: return True\n        if not a or not b: return False\n        return a.val == b.val and self.same(a.left, b.left) and self.same(a.right, b.right)"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* sub) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool same(TreeNode* a, TreeNode* b){\n        if(!a&&!b) return true; if(!a||!b) return false;\n        return a->val==b->val && same(a->left,b->left) && same(a->right,b->right);\n    }\n    bool isSubtree(TreeNode* root, TreeNode* sub){\n        if(!root) return false;\n        if(same(root,sub)) return true;\n        return isSubtree(root->left,sub)||isSubtree(root->right,sub);\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isSubtree(TreeNode root, TreeNode sub) { return false; }\n}", "solution": "class Solution {\n    public boolean isSubtree(TreeNode root, TreeNode sub){\n        if(root==null) return false;\n        if(same(root,sub)) return true;\n        return isSubtree(root.left,sub)||isSubtree(root.right,sub);\n    }\n    boolean same(TreeNode a, TreeNode b){\n        if(a==null&&b==null) return true; if(a==null||b==null) return false;\n        return a.val==b.val && same(a.left,b.left) && same(a.right,b.right);\n    }\n}"},
         "javascript": {"starter": "var isSubtree = function(root, subRoot) {\n};", "solution": "var isSubtree = function(root, sub) {\n    if(!root) return false;\n    const same=(a,b)=>{if(!a&&!b)return true;if(!a||!b)return false;return a.val===b.val&&same(a.left,b.left)&&same(a.right,b.right);};\n    if(same(root,sub)) return true;\n    return isSubtree(root.left,sub)||isSubtree(root.right,sub);\n};"},
         "c": {"starter": "bool isSubtree(struct TreeNode* root, struct TreeNode* sub) { return false; }", "solution": "bool same(struct TreeNode* a, struct TreeNode* b){\n    if(!a&&!b) return true; if(!a||!b) return false;\n    return a->val==b->val && same(a->left,b->left) && same(a->right,b->right);\n}\nbool isSubtree(struct TreeNode* root, struct TreeNode* sub){\n    if(!root) return false;\n    if(same(root,sub)) return true;\n    return isSubtree(root->left,sub)||isSubtree(root->right,sub);\n}"},
     }},
    {"number": 617, "title": "Merge Two Binary Trees", "difficulty": "easy", "topics": ["Trees", "Recursion"], "companies": ["Amazon", "Google", "Meta"],
     "description": "You are given two binary trees `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. Return the merged tree.", "constraints": "The number of nodes in both trees is in the range [0, 2000].\n-10^4 <= Node.val <= 10^4",
     "example_input": "root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]", "example_output": "[3,4,5,5,4,null,7]", "example_explanation": "Overlapping nodes are summed.",
     "hints": "If both nodes exist, sum their values.\nRecursively merge left and right.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root1 = [1,3,2,5]\nroot2 = [2,1,3,null,4,null,7]", "output": "[3,4,5,5,4,null,7]", "is_sample": True, "explanation": "Merged"},
                    {"input": "root1 = [1]\nroot2 = [1,2]", "output": "[2,2]", "is_sample": True, "explanation": "Partial overlap"},
                    {"input": "root1 = []\nroot2 = [1]", "output": "[1]", "is_sample": False, "explanation": "One empty"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def mergeTrees(self, r1: TreeNode, r2: TreeNode) -> TreeNode:\n        pass", "solution": "class Solution:\n    def mergeTrees(self, r1, r2):\n        if not r1: return r2\n        if not r2: return r1\n        r1.val += r2.val\n        r1.left = self.mergeTrees(r1.left, r2.left)\n        r1.right = self.mergeTrees(r1.right, r2.right)\n        return r1"},
         "cpp17": {"starter": "class Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* r1, TreeNode* r2) { return nullptr; }\n};", "solution": "class Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* r1, TreeNode* r2) {\n        if(!r1) return r2; if(!r2) return r1;\n        r1->val+=r2->val;\n        r1->left=mergeTrees(r1->left,r2->left);\n        r1->right=mergeTrees(r1->right,r2->right);\n        return r1;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public TreeNode mergeTrees(TreeNode r1, TreeNode r2) { return null; }\n}", "solution": "class Solution {\n    public TreeNode mergeTrees(TreeNode r1, TreeNode r2) {\n        if(r1==null) return r2; if(r2==null) return r1;\n        r1.val+=r2.val;\n        r1.left=mergeTrees(r1.left,r2.left);\n        r1.right=mergeTrees(r1.right,r2.right);\n        return r1;\n    }\n}"},
         "javascript": {"starter": "var mergeTrees = function(r1, r2) {\n};", "solution": "var mergeTrees = function(r1, r2) {\n    if(!r1) return r2; if(!r2) return r1;\n    r1.val+=r2.val;\n    r1.left=mergeTrees(r1.left,r2.left);\n    r1.right=mergeTrees(r1.right,r2.right);\n    return r1;\n};"},
         "c": {"starter": "struct TreeNode* mergeTrees(struct TreeNode* r1, struct TreeNode* r2) { return NULL; }", "solution": "struct TreeNode* mergeTrees(struct TreeNode* r1, struct TreeNode* r2) {\n    if(!r1) return r2; if(!r2) return r1;\n    r1->val+=r2->val;\n    r1->left=mergeTrees(r1->left,r2->left);\n    r1->right=mergeTrees(r1->right,r2->right);\n    return r1;\n}"},
     }},
    {"number": 647, "title": "Palindromic Substrings", "difficulty": "medium", "topics": ["Strings", "Dynamic Programming"], "companies": ["Meta", "Amazon", "Microsoft"],
     "description": "Given a string `s`, return the number of palindromic substrings in it.\n\nA string is a palindrome when it reads the same backward as forward.\n\nA substring is a contiguous sequence of characters within the string.", "constraints": "1 <= s.length <= 1000\ns consists of lowercase English letters.",
     "example_input": 's = "abc"', "example_output": "3", "example_explanation": 'Three palindromic strings: "a", "b", "c".',
     "hints": "Expand around center for each possible center.\nBoth odd and even length palindromes.", "time_complexity": "O(n^2)", "space_complexity": "O(1)",
     "test_cases": [{"input": 's = "abc"', "output": "3", "is_sample": True, "explanation": "a, b, c"},
                    {"input": 's = "aaa"', "output": "6", "is_sample": True, "explanation": "a,a,a,aa,aa,aaa"},
                    {"input": 's = "aba"', "output": "4", "is_sample": False, "explanation": "a,b,a,aba"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        pass", "solution": "class Solution:\n    def countSubstrings(self, s):\n        res = 0\n        for i in range(len(s)):\n            for l, r in [(i, i), (i, i + 1)]:\n                while l >= 0 and r < len(s) and s[l] == s[r]:\n                    res += 1; l -= 1; r += 1\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int countSubstrings(string s) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int countSubstrings(string s) {\n        int n=s.size(),res=0;\n        for(int i=0;i<n;i++){\n            for(int l=i,r=i;l>=0&&r<n&&s[l]==s[r];l--,r++) res++;\n            for(int l=i,r=i+1;l>=0&&r<n&&s[l]==s[r];l--,r++) res++;\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int countSubstrings(String s) { return 0; }\n}", "solution": "class Solution {\n    public int countSubstrings(String s) {\n        int n=s.length(),res=0;\n        for(int i=0;i<n;i++){\n            for(int l=i,r=i;l>=0&&r<n&&s.charAt(l)==s.charAt(r);l--,r++) res++;\n            for(int l=i,r=i+1;l>=0&&r<n&&s.charAt(l)==s.charAt(r);l--,r++) res++;\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var countSubstrings = function(s) {\n};", "solution": "var countSubstrings = function(s) {\n    let res=0;\n    for(let i=0;i<s.length;i++){\n        for(let l=i,r=i;l>=0&&r<s.length&&s[l]===s[r];l--,r++) res++;\n        for(let l=i,r=i+1;l>=0&&r<s.length&&s[l]===s[r];l--,r++) res++;\n    }\n    return res;\n};"},
         "c": {"starter": "int countSubstrings(char* s) { return 0; }", "solution": "int countSubstrings(char* s) {\n    int n=strlen(s),res=0;\n    for(int i=0;i<n;i++){\n        for(int l=i,r=i;l>=0&&r<n&&s[l]==s[r];l--,r++) res++;\n        for(int l=i,r=i+1;l>=0&&r<n&&s[l]==s[r];l--,r++) res++;\n    }\n    return res;\n}"},
     }},
    {"number": 739, "title": "Daily Temperatures", "difficulty": "medium", "topics": ["Arrays", "Stack"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "Given an array of integers `temperatures` represents the daily temperatures, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `i`th day to get a warmer temperature. If there is no future day with warmer temperature, keep `answer[i] == 0`.", "constraints": "1 <= temperatures.length <= 10^5\n30 <= temperatures[i] <= 100",
     "example_input": "temperatures = [73,74,75,71,69,72,76,73]", "example_output": "[1,1,4,2,1,1,0,0]", "example_explanation": "For day 0, wait 1 day for warmer temp.",
     "hints": "Use a monotonic stack.\nStack stores indices of decreasing temperatures.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "temperatures = [73,74,75,71,69,72,76,73]", "output": "[1,1,4,2,1,1,0,0]", "is_sample": True, "explanation": "Wait days for warmer"},
                    {"input": "temperatures = [30,40,50,60]", "output": "[1,1,1,0]", "is_sample": True, "explanation": "Always next day"},
                    {"input": "temperatures = [30,60,90]", "output": "[1,1,0]", "is_sample": False, "explanation": "Increasing"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n        pass", "solution": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                j = stack.pop()\n                res[j] = i - j\n            stack.append(i)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& t) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& t) {\n        int n=t.size(); vector<int> res(n,0); stack<int> st;\n        for(int i=0;i<n;i++){\n            while(!st.empty()&&t[i]>t[st.top()]){res[st.top()]=i-st.top();st.pop();}\n            st.push(i);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int[] dailyTemperatures(int[] t) { return new int[]{}; }\n}", "solution": "class Solution {\n    public int[] dailyTemperatures(int[] t) {\n        int n=t.length; int[] res=new int[n]; Stack<Integer> st=new Stack<>();\n        for(int i=0;i<n;i++){\n            while(!st.isEmpty()&&t[i]>t[st.peek()]){int j=st.pop();res[j]=i-j;}\n            st.push(i);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var dailyTemperatures = function(temperatures) {\n};", "solution": "var dailyTemperatures = function(t) {\n    const n=t.length, res=new Array(n).fill(0), st=[];\n    for(let i=0;i<n;i++){\n        while(st.length&&t[i]>t[st[st.length-1]]){const j=st.pop();res[j]=i-j;}\n        st.push(i);\n    }\n    return res;\n};"},
         "c": {"starter": "int* dailyTemperatures(int* t, int n, int* returnSize) { *returnSize=n; return NULL; }", "solution": "int* dailyTemperatures(int* t, int n, int* returnSize) {\n    *returnSize=n;\n    int* res=calloc(n,sizeof(int));\n    int st[100000],top=-1;\n    for(int i=0;i<n;i++){\n        while(top>=0&&t[i]>t[st[top]]){int j=st[top--];res[j]=i-j;}\n        st[++top]=i;\n    }\n    return res;\n}"},
     }},
    {"number": 102, "title": "Binary Tree Level Order Traversal", "difficulty": "medium", "topics": ["Trees", "Graphs"], "companies": ["Amazon", "Meta", "Microsoft"],
     "description": "Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).", "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
     "example_input": "root = [3,9,20,null,null,15,7]", "example_output": "[[3],[9,20],[15,7]]", "example_explanation": "Three levels.",
     "hints": "Use BFS with a queue.\nProcess all nodes at each level.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "root = [3,9,20,null,null,15,7]", "output": "[[3],[9,20],[15,7]]", "is_sample": True, "explanation": "3 levels"},
                    {"input": "root = [1]", "output": "[[1]]", "is_sample": True, "explanation": "Single level"},
                    {"input": "root = []", "output": "[]", "is_sample": False, "explanation": "Empty tree"}],
     "templates": {
         "python3": {"starter": "from collections import deque\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> list[list[int]]:\n        pass", "solution": "from collections import deque\nclass Solution:\n    def levelOrder(self, root):\n        if not root: return []\n        res, q = [], deque([root])\n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n            res.append(level)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) { return {}; }\n};", "solution": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res; queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int sz=q.size(); vector<int> level;\n            for(int i=0;i<sz;i++){\n                auto n=q.front();q.pop();\n                level.push_back(n->val);\n                if(n->left)q.push(n->left);\n                if(n->right)q.push(n->right);\n            }\n            res.push_back(level);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) { return new ArrayList<>(); }\n}", "solution": "class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res=new ArrayList<>();\n        if(root==null) return res;\n        Queue<TreeNode> q=new LinkedList<>(); q.add(root);\n        while(!q.isEmpty()){\n            int sz=q.size(); List<Integer> level=new ArrayList<>();\n            for(int i=0;i<sz;i++){ TreeNode n=q.poll(); level.add(n.val); if(n.left!=null)q.add(n.left); if(n.right!=null)q.add(n.right); }\n            res.add(level);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var levelOrder = function(root) {\n};", "solution": "var levelOrder = function(root) {\n    if(!root) return [];\n    const res=[]; let q=[root];\n    while(q.length){\n        const level=[], next=[];\n        for(const n of q){level.push(n.val);if(n.left)next.push(n.left);if(n.right)next.push(n.right);}\n        res.push(level); q=next;\n    }\n    return res;\n};"},
         "c": {"starter": "int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    *returnSize=0; return NULL;\n}", "solution": "int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    *returnSize=0;\n    if(!root) return NULL;\n    int** res=malloc(2000*sizeof(int*));\n    *returnColumnSizes=malloc(2000*sizeof(int));\n    struct TreeNode* q[2000]; int front=0,back=0;\n    q[back++]=root;\n    while(front<back){\n        int sz=back-front;\n        res[*returnSize]=malloc(sz*sizeof(int));\n        (*returnColumnSizes)[*returnSize]=sz;\n        for(int i=0;i<sz;i++){\n            struct TreeNode* n=q[front++];\n            res[*returnSize][i]=n->val;\n            if(n->left)q[back++]=n->left;\n            if(n->right)q[back++]=n->right;\n        }\n        (*returnSize)++;\n    }\n    return res;\n}"},
     }},
    {"number": 105, "title": "Construct Binary Tree from Preorder and Inorder Traversal", "difficulty": "medium", "topics": ["Trees", "Recursion", "Hash Table"], "companies": ["Amazon", "Google", "Microsoft"],
     "description": "Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.", "constraints": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\nAll the values of preorder and inorder are unique.",
     "example_input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]", "example_output": "[3,9,20,null,null,15,7]", "example_explanation": "Reconstructed tree.",
     "hints": "First element of preorder is the root.\nFind root in inorder to split left/right subtrees.", "time_complexity": "O(n)", "space_complexity": "O(n)",
     "test_cases": [{"input": "preorder = [3,9,20,15,7]\ninorder = [9,3,15,20,7]", "output": "[3,9,20,null,null,15,7]", "is_sample": True, "explanation": "Tree reconstructed"},
                    {"input": "preorder = [-1]\ninorder = [-1]", "output": "[-1]", "is_sample": True, "explanation": "Single node"},
                    {"input": "preorder = [1,2]\ninorder = [2,1]", "output": "[1,2]", "is_sample": False, "explanation": "Left child only"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> TreeNode:\n        pass", "solution": "class Solution:\n    def buildTree(self, preorder, inorder):\n        if not preorder: return None\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"},
         "cpp17": {"starter": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { return nullptr; }\n};", "solution": "class Solution {\n    unordered_map<int,int> inMap; int preIdx=0;\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        for(int i=0;i<inorder.size();i++) inMap[inorder[i]]=i;\n        return build(preorder,0,inorder.size()-1);\n    }\n    TreeNode* build(vector<int>& pre, int l, int r){\n        if(l>r) return nullptr;\n        TreeNode* n=new TreeNode(pre[preIdx++]);\n        n->left=build(pre,l,inMap[n->val]-1);\n        n->right=build(pre,inMap[n->val]+1,r);\n        return n;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) { return null; }\n}", "solution": "class Solution {\n    Map<Integer,Integer> inMap=new HashMap<>(); int preIdx=0;\n    public TreeNode buildTree(int[] pre, int[] in){\n        for(int i=0;i<in.length;i++) inMap.put(in[i],i);\n        return build(pre,0,in.length-1);\n    }\n    TreeNode build(int[] pre, int l, int r){\n        if(l>r) return null;\n        TreeNode n=new TreeNode(pre[preIdx++]);\n        n.left=build(pre,l,inMap.get(n.val)-1);\n        n.right=build(pre,inMap.get(n.val)+1,r);\n        return n;\n    }\n}"},
         "javascript": {"starter": "var buildTree = function(preorder, inorder) {\n};", "solution": "var buildTree = function(pre, ino) {\n    if(!pre.length) return null;\n    const root={val:pre[0],left:null,right:null};\n    const mid=ino.indexOf(pre[0]);\n    root.left=buildTree(pre.slice(1,mid+1),ino.slice(0,mid));\n    root.right=buildTree(pre.slice(mid+1),ino.slice(mid+1));\n    return root;\n};"},
         "c": {"starter": "struct TreeNode* buildTree(int* pre, int ps, int* ino, int is) { return NULL; }", "solution": "struct TreeNode* build(int* pre, int* pi, int* ino, int l, int r) {\n    if(l>r) return NULL;\n    struct TreeNode* n=malloc(sizeof(struct TreeNode));\n    n->val=pre[(*pi)++]; n->left=n->right=NULL;\n    int mid=l; while(ino[mid]!=n->val) mid++;\n    n->left=build(pre,pi,ino,l,mid-1);\n    n->right=build(pre,pi,ino,mid+1,r);\n    return n;\n}\nstruct TreeNode* buildTree(int* pre, int ps, int* ino, int is) {\n    int pi=0; return build(pre,&pi,ino,0,is-1);\n}"},
     }},
    {"number": 79, "title": "Word Search", "difficulty": "medium", "topics": ["Arrays", "Backtracking", "Matrix"], "companies": ["Amazon", "Microsoft", "Bloomberg"],
     "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.", "constraints": "m == board.length\nn == board[i].length\n1 <= m, n <= 6\n1 <= word.length <= 15\nboard and word consists of only lowercase and uppercase English letters.",
     "example_input": 'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"', "example_output": "true", "example_explanation": "Path: A->B->C->C->E->D.",
     "hints": "Use DFS with backtracking.\nMark cells as visited during search.", "time_complexity": "O(m*n*4^L)", "space_complexity": "O(L)",
     "test_cases": [{"input": 'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]\nword = "ABCCED"', "output": "true", "is_sample": True, "explanation": "Path exists"},
                    {"input": 'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]\nword = "SEE"', "output": "true", "is_sample": True, "explanation": "Path exists"},
                    {"input": 'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]\nword = "ABCB"', "output": "false", "is_sample": False, "explanation": "Cannot reuse cells"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        pass", "solution": "class Solution:\n    def exist(self, board, word):\n        m, n = len(board), len(board[0])\n        def dfs(i, j, k):\n            if k == len(word): return True\n            if i<0 or i>=m or j<0 or j>=n or board[i][j] != word[k]: return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            found = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = tmp\n            return found\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0): return True\n        return False"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& b, string w) {\n        int m=b.size(),n=b[0].size();\n        function<bool(int,int,int)> dfs=[&](int i,int j,int k)->bool{\n            if(k==w.size()) return true;\n            if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false;\n            char t=b[i][j]; b[i][j]='#';\n            bool f=dfs(i+1,j,k+1)||dfs(i-1,j,k+1)||dfs(i,j+1,k+1)||dfs(i,j-1,k+1);\n            b[i][j]=t; return f;\n        };\n        for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(i,j,0)) return true;\n        return false;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean exist(char[][] board, String word) { return false; }\n}", "solution": "class Solution {\n    public boolean exist(char[][] b, String w) {\n        for(int i=0;i<b.length;i++) for(int j=0;j<b[0].length;j++) if(dfs(b,w,i,j,0)) return true;\n        return false;\n    }\n    boolean dfs(char[][] b, String w, int i, int j, int k) {\n        if(k==w.length()) return true;\n        if(i<0||i>=b.length||j<0||j>=b[0].length||b[i][j]!=w.charAt(k)) return false;\n        char t=b[i][j]; b[i][j]='#';\n        boolean f=dfs(b,w,i+1,j,k+1)||dfs(b,w,i-1,j,k+1)||dfs(b,w,i,j+1,k+1)||dfs(b,w,i,j-1,k+1);\n        b[i][j]=t; return f;\n    }\n}"},
         "javascript": {"starter": "var exist = function(board, word) {\n};", "solution": "var exist = function(b, w) {\n    const m=b.length,n=b[0].length;\n    const dfs=(i,j,k)=>{\n        if(k===w.length) return true;\n        if(i<0||i>=m||j<0||j>=n||b[i][j]!==w[k]) return false;\n        const t=b[i][j]; b[i][j]='#';\n        const f=dfs(i+1,j,k+1)||dfs(i-1,j,k+1)||dfs(i,j+1,k+1)||dfs(i,j-1,k+1);\n        b[i][j]=t; return f;\n    };\n    for(let i=0;i<m;i++) for(let j=0;j<n;j++) if(dfs(i,j,0)) return true;\n    return false;\n};"},
         "c": {"starter": "bool exist(char** board, int m, int* colSizes, char* word) { return false; }", "solution": "bool dfs(char** b, int m, int n, char* w, int i, int j, int k) {\n    if(!w[k]) return true;\n    if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false;\n    char t=b[i][j]; b[i][j]='#';\n    bool f=dfs(b,m,n,w,i+1,j,k+1)||dfs(b,m,n,w,i-1,j,k+1)||dfs(b,m,n,w,i,j+1,k+1)||dfs(b,m,n,w,i,j-1,k+1);\n    b[i][j]=t; return f;\n}\nbool exist(char** b, int m, int* cs, char* w) {\n    int n=cs[0];\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(b,m,n,w,i,j,0)) return true;\n    return false;\n}"},
     }},
    {"number": 152, "title": "Maximum Product Subarray", "difficulty": "medium", "topics": ["Arrays", "Dynamic Programming"], "companies": ["Amazon", "Google", "Bloomberg"],
     "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.", "constraints": "1 <= nums.length <= 2 * 10^4\n-10 <= nums[i] <= 10\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
     "example_input": "nums = [2,3,-2,4]", "example_output": "6", "example_explanation": "[2,3] has the largest product 6.",
     "hints": "Track both max and min products at each position.\nMin can become max when multiplied by negative.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "nums = [2,3,-2,4]", "output": "6", "is_sample": True, "explanation": "[2,3]=6"},
                    {"input": "nums = [-2,0,-1]", "output": "0", "is_sample": True, "explanation": "[0]=0"},
                    {"input": "nums = [-2,3,-4]", "output": "24", "is_sample": False, "explanation": "[-2,3,-4]=24"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def maxProduct(self, nums: list[int]) -> int:\n        pass", "solution": "class Solution:\n    def maxProduct(self, nums):\n        res = mx = mn = nums[0]\n        for n in nums[1:]:\n            if n < 0: mx, mn = mn, mx\n            mx = max(n, mx * n)\n            mn = min(n, mn * n)\n            res = max(res, mx)\n        return res"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int res=nums[0],mx=nums[0],mn=nums[0];\n        for(int i=1;i<nums.size();i++){\n            if(nums[i]<0) swap(mx,mn);\n            mx=max(nums[i],mx*nums[i]);\n            mn=min(nums[i],mn*nums[i]);\n            res=max(res,mx);\n        }\n        return res;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int maxProduct(int[] nums) { return 0; }\n}", "solution": "class Solution {\n    public int maxProduct(int[] nums) {\n        int res=nums[0],mx=nums[0],mn=nums[0];\n        for(int i=1;i<nums.length;i++){\n            if(nums[i]<0){int t=mx;mx=mn;mn=t;}\n            mx=Math.max(nums[i],mx*nums[i]);\n            mn=Math.min(nums[i],mn*nums[i]);\n            res=Math.max(res,mx);\n        }\n        return res;\n    }\n}"},
         "javascript": {"starter": "var maxProduct = function(nums) {\n};", "solution": "var maxProduct = function(nums) {\n    let res=nums[0],mx=nums[0],mn=nums[0];\n    for(let i=1;i<nums.length;i++){\n        if(nums[i]<0)[mx,mn]=[mn,mx];\n        mx=Math.max(nums[i],mx*nums[i]);\n        mn=Math.min(nums[i],mn*nums[i]);\n        res=Math.max(res,mx);\n    }\n    return res;\n};"},
         "c": {"starter": "int maxProduct(int* nums, int n) { return 0; }", "solution": "int maxProduct(int* nums, int n) {\n    int res=nums[0],mx=nums[0],mn=nums[0];\n    for(int i=1;i<n;i++){\n        if(nums[i]<0){int t=mx;mx=mn;mn=t;}\n        mx=nums[i]>mx*nums[i]?nums[i]:mx*nums[i];\n        mn=nums[i]<mn*nums[i]?nums[i]:mn*nums[i];\n        if(mx>res)res=mx;\n    }\n    return res;\n}"},
     }},
    {"number": 191, "title": "Number of 1 Bits", "difficulty": "easy", "topics": ["Bit Manipulation"], "companies": ["Amazon", "Microsoft", "Apple"],
     "description": "Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).", "constraints": "1 <= n <= 2^31 - 1",
     "example_input": "n = 11", "example_output": "3", "example_explanation": "11 in binary is 1011, which has 3 set bits.",
     "hints": "Use n & (n-1) to clear the lowest set bit.\nCount iterations.", "time_complexity": "O(1)", "space_complexity": "O(1)",
     "test_cases": [{"input": "n = 11", "output": "3", "is_sample": True, "explanation": "1011 has 3 ones"},
                    {"input": "n = 128", "output": "1", "is_sample": True, "explanation": "10000000 has 1 one"},
                    {"input": "n = 2147483645", "output": "30", "is_sample": False, "explanation": "Large number"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        pass", "solution": "class Solution:\n    def hammingWeight(self, n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count"},
         "cpp17": {"starter": "class Solution {\npublic:\n    int hammingWeight(int n) { return 0; }\n};", "solution": "class Solution {\npublic:\n    int hammingWeight(int n) {\n        int cnt=0;\n        while(n){n&=n-1;cnt++;}\n        return cnt;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public int hammingWeight(int n) { return 0; }\n}", "solution": "class Solution {\n    public int hammingWeight(int n) {\n        int cnt=0;\n        while(n!=0){n&=n-1;cnt++;}\n        return cnt;\n    }\n}"},
         "javascript": {"starter": "var hammingWeight = function(n) {\n};", "solution": "var hammingWeight = function(n) {\n    let cnt=0;\n    while(n){n&=n-1;cnt++;}\n    return cnt;\n};"},
         "c": {"starter": "int hammingWeight(int n) { return 0; }", "solution": "int hammingWeight(int n) {\n    int cnt=0;\n    while(n){n&=n-1;cnt++;}\n    return cnt;\n}"},
     }},
    {"number": 234, "title": "Palindrome Linked List", "difficulty": "easy", "topics": ["Linked List", "Two Pointers", "Recursion"], "companies": ["Meta", "Amazon", "Google"],
     "description": "Given the `head` of a singly linked list, return `true` if it is a palindrome or `false` otherwise.", "constraints": "The number of nodes in the list is in the range [1, 10^5].\n0 <= Node.val <= 9",
     "example_input": "head = [1,2,2,1]", "example_output": "true", "example_explanation": "Reads same forward and backward.",
     "hints": "Find the middle with slow/fast pointers.\nReverse the second half and compare.", "time_complexity": "O(n)", "space_complexity": "O(1)",
     "test_cases": [{"input": "head = [1,2,2,1]", "output": "true", "is_sample": True, "explanation": "Palindrome"},
                    {"input": "head = [1,2]", "output": "false", "is_sample": True, "explanation": "Not palindrome"},
                    {"input": "head = [1]", "output": "true", "is_sample": False, "explanation": "Single node"}],
     "templates": {
         "python3": {"starter": "class Solution:\n    def isPalindrome(self, head: ListNode) -> bool:\n        pass", "solution": "class Solution:\n    def isPalindrome(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next; fast = fast.next.next\n        prev = None\n        while slow:\n            nxt = slow.next; slow.next = prev; prev = slow; slow = nxt\n        while prev:\n            if head.val != prev.val: return False\n            head = head.next; prev = prev.next\n        return True"},
         "cpp17": {"starter": "class Solution {\npublic:\n    bool isPalindrome(ListNode* head) { return false; }\n};", "solution": "class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode *slow=head,*fast=head;\n        while(fast&&fast->next){slow=slow->next;fast=fast->next->next;}\n        ListNode* prev=nullptr;\n        while(slow){ListNode* nxt=slow->next;slow->next=prev;prev=slow;slow=nxt;}\n        while(prev){if(head->val!=prev->val)return false;head=head->next;prev=prev->next;}\n        return true;\n    }\n};"},
         "java": {"starter": "class Solution {\n    public boolean isPalindrome(ListNode head) { return false; }\n}", "solution": "class Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode slow=head,fast=head;\n        while(fast!=null&&fast.next!=null){slow=slow.next;fast=fast.next.next;}\n        ListNode prev=null;\n        while(slow!=null){ListNode nxt=slow.next;slow.next=prev;prev=slow;slow=nxt;}\n        while(prev!=null){if(head.val!=prev.val)return false;head=head.next;prev=prev.next;}\n        return true;\n    }\n}"},
         "javascript": {"starter": "var isPalindrome = function(head) {\n};", "solution": "var isPalindrome = function(head) {\n    let slow=head,fast=head;\n    while(fast&&fast.next){slow=slow.next;fast=fast.next.next;}\n    let prev=null;\n    while(slow){let nxt=slow.next;slow.next=prev;prev=slow;slow=nxt;}\n    while(prev){if(head.val!==prev.val)return false;head=head.next;prev=prev.next;}\n    return true;\n};"},
         "c": {"starter": "bool isPalindrome(struct ListNode* head) { return false; }", "solution": "bool isPalindrome(struct ListNode* head) {\n    struct ListNode *slow=head,*fast=head;\n    while(fast&&fast->next){slow=slow->next;fast=fast->next->next;}\n    struct ListNode* prev=NULL;\n    while(slow){struct ListNode* nxt=slow->next;slow->next=prev;prev=slow;slow=nxt;}\n    while(prev){if(head->val!=prev->val)return false;head=head->next;prev=prev->next;}\n    return true;\n}"},
     }},
]
